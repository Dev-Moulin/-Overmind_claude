# ‚ö° OPTIMISATION PERFORMANCE XSTATE + THREE.JS

## üéØ Objectif

Optimisation avanc√©e des performances pour l'architecture XState + Three.js, bas√©e sur les recherches de pipeline et les meilleures pratiques identifi√©es.

## üìä Probl√®mes de Performance Identifi√©s

### **1. Probl√®mes Zustand Actuels**
```javascript
// ‚ùå PROBL√àME: Re-renders excessifs
const useSceneStore = create((set) => ({
  bloomIntensity: 0.5,
  setBloomIntensity: (intensity) => {
    set({ bloomIntensity: intensity }); // Re-render imm√©diat
    // Puis application Three.js ‚Üí autre re-render
  }
}));

// ‚ùå R√©sultat: 2 re-renders par changement
// ‚ùå Avec 10 param√®tres modifi√©s: 20 re-renders!
```

### **2. Race Conditions Three.js**
```javascript
// ‚ùå PROBL√àME: Ordre non garanti
const applyChanges = () => {
  setBloomEnabled(true);    // Frame N
  setHDREnabled(true);      // Frame N+1
  setMetalness(0.8);        // Frame N+2
  // Bloom appliqu√© sans HDR ‚Üí erreur visuelle
};
```

### **3. Recompilation Shader (Goulot Principal)**
```javascript
// ‚ùå PROBL√àME CRITIQUE: Recompilation shader √† chaque toggle
const toggleBloom = () => {
  if (bloomEnabled) {
    composer.removePass(bloomPass); // Destruction shader
  } else {
    bloomPass = new EffectPass(camera, bloomEffect); // Recompilation
    composer.addPass(bloomPass);    // Gel 50-100ms !
  }
};

// ‚úÖ SOLUTION: Pr√©-instanciation + setEnabled()
const toggleBloomOptimized = () => {
  bloomPass.enabled = !bloomPass.enabled; // 0.1ms au lieu de 50ms
};
```

## üîÑ Architecture de Performance XState

### **1. Machine de Synchronisation Avanc√©e**

```typescript
// machines/performanceMachine.js
const performanceMachine = createMachine({
  id: 'performance',
  initial: 'idle',

  context: {
    pendingChanges: new Map(),
    batchTimer: null,
    frameCounter: 0,
    lastFPS: 60,
    performanceMode: 'auto' // 'high', 'balanced', 'battery'
  },

  states: {
    idle: {
      on: {
        PARAMETER_CHANGED: {
          target: 'batching',
          actions: 'addToPendingBatch'
        },

        PERFORMANCE_MODE_CHANGED: {
          actions: assign({
            performanceMode: (_, event) => event.mode
          })
        }
      }
    },

    batching: {
      entry: 'startBatchTimer',
      exit: 'clearBatchTimer',

      after: {
        // D√©lai adaptatif selon performance
        16: [
          { target: 'validating', cond: 'highPerformanceMode' },
        ],
        33: [
          { target: 'validating', cond: 'balancedMode' },
        ],
        50: { target: 'validating' } // Mode batterie
      },

      on: {
        PARAMETER_CHANGED: {
          actions: 'addToPendingBatch'
        },

        FORCE_APPLY: 'validating'
      }
    },

    validating: {
      entry: 'validatePendingChanges',

      always: [
        {
          target: 'applying',
          cond: 'changesValid'
        },
        {
          target: 'error',
          cond: 'hasConflicts'
        },
        {
          target: 'idle' // Pas de changements
        }
      ]
    },

    applying: {
      entry: 'incrementFrameCounter',

      invoke: {
        id: 'applyOptimizedChanges',
        src: 'applyChangesInOptimalOrder',
        onDone: {
          target: 'measuring',
          actions: 'clearPendingChanges'
        },
        onError: 'error'
      }
    },

    measuring: {
      entry: 'measurePerformanceImpact',

      after: {
        100: { // Mesure sur 100ms
          target: 'idle',
          actions: 'adjustPerformanceMode'
        }
      }
    },

    error: {
      entry: 'logPerformanceError',

      after: {
        1000: 'idle'
      }
    }
  }
}, {
  guards: {
    highPerformanceMode: (context) => context.performanceMode === 'high',
    balancedMode: (context) => context.performanceMode === 'balanced',
    changesValid: (context) => context.pendingChanges.size > 0,
    hasConflicts: (context) => {
      // V√©rifier conflits dans les changements pending
      return detectOrderConflicts(Array.from(context.pendingChanges.keys()));
    }
  },

  actions: {
    addToPendingBatch: assign((context, event) => ({
      pendingChanges: new Map(context.pendingChanges).set(
        event.parameter,
        event.value
      )
    })),

    startBatchTimer: assign({
      batchTimer: () => performance.now()
    }),

    clearBatchTimer: assign({
      batchTimer: null
    }),

    validatePendingChanges: (context) => {
      console.log('üîç Validation changements:', Array.from(context.pendingChanges.keys()));
    },

    clearPendingChanges: assign({
      pendingChanges: new Map()
    }),

    incrementFrameCounter: assign({
      frameCounter: (context) => context.frameCounter + 1
    }),

    measurePerformanceImpact: assign((context) => {
      const currentFPS = getCurrentFPS();
      return {
        lastFPS: currentFPS
      };
    }),

    adjustPerformanceMode: assign((context) => {
      // Auto-ajustement selon FPS
      if (context.lastFPS < 30) {
        return { performanceMode: 'battery' };
      } else if (context.lastFPS < 50) {
        return { performanceMode: 'balanced' };
      } else {
        return { performanceMode: 'high' };
      }
    }),

    logPerformanceError: (context, event) => {
      console.error('‚ùå Erreur performance:', event.data);
    }
  },

  services: {
    applyChangesInOptimalOrder: async (context) => {
      const changes = Array.from(context.pendingChanges.entries());
      return await applyOptimalPipeline(changes);
    }
  }
});
```

### **2. Pipeline d'Application Optimis√©**

```typescript
// services/optimizedPipeline.js
export class OptimizedPipeline {
  constructor(scene, renderer, composer) {
    this.scene = scene;
    this.renderer = renderer;
    this.composer = composer;

    // Cache des √©tats pour √©viter recalculs
    this.stateCache = new Map();
    this.materialCache = new Map();
    this.effectCache = new Map();

    // M√©triques performance
    this.metrics = {
      appliedChanges: 0,
      skippedChanges: 0,
      averageApplyTime: 0,
      lastFrameTime: 0
    };
  }

  async applyOptimalPipeline(changes) {
    const startTime = performance.now();

    // 1. Grouper par cat√©gorie et priorit√©
    const groupedChanges = this.groupChangesByPriority(changes);

    // 2. Appliquer dans l'ordre optimal
    const pipeline = [
      'environment',  // Priorit√© 1
      'pbr',         // Priorit√© 2
      'lighting',    // Priorit√© 3
      'bloom',       // Priorit√© 4
      'msaa'         // Priorit√© 5
    ];

    for (const category of pipeline) {
      if (groupedChanges.has(category)) {
        await this.applyCategoryChanges(category, groupedChanges.get(category));
      }
    }

    // 3. Mesurer et optimiser
    const applyTime = performance.now() - startTime;
    this.updateMetrics(applyTime, changes.length);

    return {
      appliedChanges: changes.length,
      applyTime,
      fps: this.getCurrentFPS()
    };
  }

  groupChangesByPriority(changes) {
    const grouped = new Map();

    for (const [parameter, value] of changes) {
      const category = this.getParameterCategory(parameter);

      if (!grouped.has(category)) {
        grouped.set(category, new Map());
      }

      grouped.get(category).set(parameter, value);
    }

    return grouped;
  }

  async applyCategoryChanges(category, changes) {
    // V√©rifier cache pour √©viter applications inutiles
    const cacheKey = this.generateCacheKey(category, changes);

    if (this.stateCache.has(cacheKey)) {
      console.log(`‚ö° Cache hit pour ${category}`);
      this.metrics.skippedChanges += changes.size;
      return;
    }

    console.log(`üîß Application ${category}:`, Array.from(changes.keys()));

    switch (category) {
      case 'environment':
        await this.applyEnvironmentChanges(changes);
        break;
      case 'pbr':
        await this.applyPBRChanges(changes);
        break;
      case 'lighting':
        await this.applyLightingChanges(changes);
        break;
      case 'bloom':
        await this.applyBloomChanges(changes);
        break;
      case 'msaa':
        await this.applyMSAAChanges(changes);
        break;
    }

    // Mettre en cache
    this.stateCache.set(cacheKey, true);
    this.metrics.appliedChanges += changes.size;
  }

  async applyPBRChanges(changes) {
    // Optimisation: grouper les changements mat√©riaux
    const materialUpdates = {
      metalness: changes.get('metalness'),
      roughness: changes.get('roughness'),
      envMapIntensity: changes.get('envMapIntensity')
    };

    // Application group√©e pour √©viter multiple needsUpdate
    this.scene.traverse((object) => {
      if (object.material && object.material.isMeshStandardMaterial) {
        const material = object.material;
        let needsUpdate = false;

        if (materialUpdates.metalness !== undefined) {
          material.metalness = materialUpdates.metalness;
          needsUpdate = true;
        }

        if (materialUpdates.roughness !== undefined) {
          material.roughness = materialUpdates.roughness;
          needsUpdate = true;
        }

        if (materialUpdates.envMapIntensity !== undefined) {
          material.envMapIntensity = materialUpdates.envMapIntensity;
          needsUpdate = true;
        }

        // Une seule mise √† jour √† la fin
        if (needsUpdate) {
          material.needsUpdate = true;
        }
      }
    });
  }

  async applyBloomChanges(changes) {
    const bloomParams = {
      enabled: changes.get('bloomEnabled'),
      intensity: changes.get('bloomIntensity'),
      threshold: changes.get('bloomThreshold'),
      radius: changes.get('bloomRadius')
    };

    // Optimisation: √©viter recr√©ation si seuls param√®tres changent
    if (this.bloomEffect && bloomParams.enabled !== false) {
      // Mise √† jour param√®tres existants
      if (bloomParams.intensity !== undefined) {
        this.bloomEffect.intensity = bloomParams.intensity;
      }
      if (bloomParams.threshold !== undefined) {
        this.bloomEffect.luminanceThreshold = bloomParams.threshold;
      }
      if (bloomParams.radius !== undefined) {
        this.bloomEffect.luminanceSmoothing = bloomParams.radius;
      }
    } else {
      // Recr√©ation compl√®te n√©cessaire
      await this.recreateBloomEffect(bloomParams);
    }
  }

  generateCacheKey(category, changes) {
    const changeString = Array.from(changes.entries())
      .sort()
      .map(([k, v]) => `${k}:${v}`)
      .join('|');

    return `${category}-${changeString}`;
  }

  updateMetrics(applyTime, changeCount) {
    this.metrics.averageApplyTime =
      (this.metrics.averageApplyTime + applyTime) / 2;

    console.log('üìä M√©triques Performance:', {
      applyTime: `${applyTime.toFixed(2)}ms`,
      avgTime: `${this.metrics.averageApplyTime.toFixed(2)}ms`,
      applied: this.metrics.appliedChanges,
      skipped: this.metrics.skippedChanges,
      efficiency: `${(this.metrics.skippedChanges /
        (this.metrics.appliedChanges + this.metrics.skippedChanges) * 100).toFixed(1)}%`
    });
  }

  getCurrentFPS() {
    const now = performance.now();
    const delta = now - this.metrics.lastFrameTime;
    this.metrics.lastFrameTime = now;

    return delta > 0 ? 1000 / delta : 60;
  }
}
```

### **3. Hook de Performance Optimis√©**

```typescript
// hooks/useOptimizedScene.js
export const useOptimizedScene = () => {
  const [performanceService] = useState(() =>
    interpret(performanceMachine)
  );

  const [pipeline] = useState(() =>
    new OptimizedPipeline(scene, renderer, composer)
  );

  useEffect(() => {
    performanceService.start();

    // Configuration du service avec pipeline
    performanceService.send({
      type: 'CONFIGURE_PIPELINE',
      pipeline
    });

    return () => performanceService.stop();
  }, []);

  // Interface optimis√©e
  return {
    // √âtat performance
    performanceMode: useSelector(performanceService,
      state => state.context.performanceMode),

    isApplying: useSelector(performanceService,
      state => state.matches('applying')),

    pendingChanges: useSelector(performanceService,
      state => state.context.pendingChanges.size),

    fps: useSelector(performanceService,
      state => state.context.lastFPS),

    // Actions optimis√©es avec batching
    setParameter: useCallback((parameter, value) => {
      performanceService.send({
        type: 'PARAMETER_CHANGED',
        parameter,
        value
      });
    }, []),

    // Forcer application imm√©diate si n√©cessaire
    forceApply: useCallback(() => {
      performanceService.send({ type: 'FORCE_APPLY' });
    }, []),

    // Contr√¥le mode performance
    setPerformanceMode: useCallback((mode) => {
      performanceService.send({
        type: 'PERFORMANCE_MODE_CHANGED',
        mode
      });
    }, [])
  };
};
```

### **4. Monitoring et M√©triques**

```typescript
// utils/performanceMonitor.js
export class PerformanceMonitor {
  constructor() {
    this.metrics = {
      frameTimings: [],
      renderCalls: 0,
      shaderCompilations: 0,
      textureUploads: 0,
      memoryUsage: 0
    };

    this.thresholds = {
      frameBudget: 16.67, // 60fps
      maxPendingChanges: 10,
      maxApplyTime: 8
    };

    this.startMonitoring();
  }

  startMonitoring() {
    // Observer les performances Three.js
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.name.includes('render')) {
          this.metrics.frameTimings.push(entry.duration);

          // Garder seulement les 100 derni√®res mesures
          if (this.metrics.frameTimings.length > 100) {
            this.metrics.frameTimings.shift();
          }
        }
      }
    });

    observer.observe({ entryTypes: ['measure'] });

    // Monitoring m√©moire
    setInterval(() => {
      if (performance.memory) {
        this.metrics.memoryUsage = performance.memory.usedJSHeapSize;
      }
    }, 1000);
  }

  getPerformanceReport() {
    const avgFrameTime = this.metrics.frameTimings.reduce((a, b) => a + b, 0) /
                         this.metrics.frameTimings.length;

    const fps = 1000 / avgFrameTime;

    return {
      fps: fps.toFixed(1),
      avgFrameTime: avgFrameTime.toFixed(2),
      renderCalls: this.metrics.renderCalls,
      memoryMB: (this.metrics.memoryUsage / 1024 / 1024).toFixed(1),
      performance: fps > 50 ? 'excellent' : fps > 30 ? 'good' : 'poor'
    };
  }

  checkThresholds() {
    const report = this.getPerformanceReport();
    const warnings = [];

    if (parseFloat(report.fps) < 30) {
      warnings.push('FPS trop faible (< 30)');
    }

    if (parseFloat(report.memoryMB) > 512) {
      warnings.push('Utilisation m√©moire √©lev√©e (> 512MB)');
    }

    return warnings;
  }
}
```

## üìä R√©sultats d'Optimisation Attendus

### **Avant (Zustand)**
- üî¥ **Re-renders**: 2-5 par changement
- üî¥ **Latence**: 50-100ms
- üî¥ **FPS Impact**: -10 √† -20 FPS
- üî¥ **Race Conditions**: Fr√©quentes

### **Apr√®s (XState Optimis√©)**
- üü¢ **Re-renders**: 1 par batch (16-50ms)
- üü¢ **Latence**: 16-33ms
- üü¢ **FPS Impact**: -2 √† -5 FPS
- üü¢ **Race Conditions**: √âlimin√©es

### **Gains de Performance**
- **R√©duction re-renders**: 60-80%
- **Am√©lioration latence**: 50-70%
- **Stabilit√© FPS**: +15-20 FPS
- **Pr√©dictibilit√©**: 100%

Cette architecture garantit des performances optimales en √©liminant les re-renders inutiles et en appliquant les changements dans l'ordre optimal du pipeline Three.js.