// üéõÔ∏è BloomControlCenter V6 - SYST√àME UNIFI√â RESTAUR√â DE V5
import * as THREE from 'three';

export class BloomControlCenter {
  constructor(renderingEngine = null) {
    // ‚úÖ COORDINATION : Injection moteur de rendu SimpleBloomSystem
    this.renderingEngine = renderingEngine;
    
    // üìä COLLECTIONS D'OBJETS PAR TYPE
    this.objectsByType = {
      eyeRings: new Map(),     // üëÅÔ∏è Anneaux_Eye_Ext/Int
      iris: new Map(),         // üéØ IRIS
      magicRings: new Map(),   // üíç Ring_SG1, Ring_SG2, etc.
      arms: new Map(),         // ü§ñ BigArm, LittleArm, etc.
      revealRings: new Map()   // üîÆ Anneaux de r√©v√©lation
    };

    // üé® CONFIGURATIONS PAR TYPE D'OBJET
    this.materialConfigs = {
      eyeRings: {
        emissive: 0x00ff88,      // Vert eye par d√©faut
        emissiveIntensity: 1.0,
        metalness: 0.8,
        roughness: 0.2
      },
      iris: {
        emissive: 0x00ff88,      // M√™me vert que eye rings
        emissiveIntensity: 1.0,
        metalness: 0.8,
        roughness: 0.2
      },
      magicRings: {
        emissive: 0x4488ff,      // Bleu magique
        emissiveIntensity: 1.0,
        metalness: 0.8,
        roughness: 0.2
      },
      arms: {
        emissive: 0x6666ff,      // Bleu m√©tallique
        emissiveIntensity: 1.0,
        metalness: 0.8,
        roughness: 0.2
      },
      revealRings: {
        emissive: 0xffaa00,      // Orange r√©v√©lation
        emissiveIntensity: 0.5,
        metalness: 0.8,
        roughness: 0.2
      }
    };

    // üåü CONFIGURATION POST-PROCESSING BLOOM - ‚úÖ CCS: Valeurs par d√©faut, seront √©cras√©es par SceneStateController
    this.postProcessConfig = {
      threshold: 0.15,   // Seuil luminance - sera synchronis√© par CCS
      strength: 0.40,    // Intensit√© bloom - sera synchronis√© par CCS  
      radius: 1.0,       // Rayon diffusion
      exposure: 1.2      // Exposition globale
    };

    // üîí PRESETS S√âCURIT√â COMPLETS
    this.securityPresets = {
      SAFE: {
        eyeRings: { emissive: 0x00ff88, emissiveIntensity: 0.3 },
        iris: { emissive: 0x00ff88, emissiveIntensity: 0.4 },
        magicRings: { emissive: 0x88ff88, emissiveIntensity: 0.15 },
        arms: { emissive: 0x44ff44, emissiveIntensity: 0.03 },
        revealRings: { emissive: 0x88ff88, emissiveIntensity: 0.3 }
      },
      DANGER: {
        eyeRings: { emissive: 0xff4444, emissiveIntensity: 0.8 },
        iris: { emissive: 0xff2222, emissiveIntensity: 1.0 },
        magicRings: { emissive: 0xff6666, emissiveIntensity: 0.4 },
        arms: { emissive: 0xff8888, emissiveIntensity: 0.1 },
        revealRings: { emissive: 0xff4444, emissiveIntensity: 0.6 }
      },
      WARNING: {
        eyeRings: { emissive: 0xffaa00, emissiveIntensity: 0.5 },
        iris: { emissive: 0xff8800, emissiveIntensity: 0.6 },
        magicRings: { emissive: 0xffcc44, emissiveIntensity: 0.25 },
        arms: { emissive: 0xffdd66, emissiveIntensity: 0.05 },
        revealRings: { emissive: 0xffaa00, emissiveIntensity: 0.4 }
      },
      SCANNING: {
        eyeRings: { emissive: 0x4488ff, emissiveIntensity: 0.6 },
        iris: { emissive: 0x2266ff, emissiveIntensity: 0.7 },
        magicRings: { emissive: 0x66aaff, emissiveIntensity: 0.3 },
        arms: { emissive: 0x88ccff, emissiveIntensity: 0.06 },
        revealRings: { emissive: 0x4488ff, emissiveIntensity: 0.5 }
      },
      NORMAL: {
        eyeRings: { emissive: 0xffffff, emissiveIntensity: 0.8 }, // üîß DOUBL√â pour visibilit√© maximale
        iris: { emissive: 0xffffff, emissiveIntensity: 0.5 },     // üîß Blanc pur pour coh√©rence
        magicRings: { emissive: 0xffffff, emissiveIntensity: 0.3 }, // üîß AUGMENT√â + blanc pur
        arms: { emissive: 0xffffff, emissiveIntensity: 0.1 },   // üîß DOUBL√â + blanc pur
        revealRings: { emissive: 0xffffff, emissiveIntensity: 0.6 } // üîß AUGMENT√â pour test
      }
    };

    // üîÑ ANIMATION ET STATE
    this.currentSecurityState = null; // Pas de preset par d√©faut
    this.animationTime = 0;
    this.transitionSpeed = 2.0;
    this.pulseEnabled = false;
    
  }

  // üîç D√âTECTION ET ENREGISTREMENT D'OBJETS PR√âCISE (CORRIG√âE)
  detectAndRegisterBloomObjects(model) {
    if (!model) {
      console.warn('üéõÔ∏è BloomControlCenter: Aucun mod√®le fourni');
      return 0;
    }

    let detectedCount = 0;
    // ‚úÖ SUPPRIM√â : Log de d√©but pour r√©duire spam console

    model.traverse((child) => {
      if (!child.isMesh || !child.material) return;

      const name = child.name.toLowerCase();
      // ‚úÖ SUPPRIM√â : Log d'analyse pour chaque objet pour r√©duire spam console
      
      // üëÅÔ∏è EYE RINGS DETECTION - PR√âCISE (anneaux_eye seulement)
      if (name.includes('anneaux_eye')) {
        this.registerObject('eyeRings', child.name, child);
        detectedCount++;
      }
      // üéØ IRIS DETECTION  
      else if (name.includes('iris')) {
        this.registerObject('iris', child.name, child);
        detectedCount++;
      }
      // üîÆ REVEAL RINGS DETECTION - CORRECTION PATTERN
      else if (name.includes('ring_bloomarea') || name.includes('action_ring') || name.includes('bloomarea')) {
        this.registerObject('revealRings', child.name, child);
        detectedCount++;
      }
      // üíç MAGIC RINGS DETECTION (Ring_SG pattern) - ‚úÖ CORRECTION: SG1 rings go to revealRings pour test
      else if (name.includes('ring_ext_sg1') || name.includes('ring_int_sg1')) {
        // ‚úÖ SUPPRIM√â : Log de debug SG1 pour r√©duire spam console
        this.registerObject('revealRings', child.name, child);
        detectedCount++;
      }
      else if (name.includes('ring_sg') || (name.includes('ring') && !name.includes('eye'))) {
        this.registerObject('magicRings', child.name, child);
        detectedCount++;
      }
      // ü§ñ ARMS DETECTION
      else if (name.includes('bigarm') || name.includes('littlearm') || name.includes('bras')) {
        this.registerObject('arms', child.name, child);
        detectedCount++;
      }
    });

    // üìä R√©sum√© d√©tection
    console.log('üìä BloomControlCenter - R√©sum√© d√©tection:');
    Object.keys(this.objectsByType).forEach(type => {
      const count = this.objectsByType[type].size;
      console.log(`   ‚Ä¢ ${type}: ${count} objets`);
      if (count > 0) {
        this.objectsByType[type].forEach((obj, name) => {
          console.log(`     - ${name}`);
        });
      }
    });
    
    // üé® Appliquer configuration initiale
    this.applyInitialMaterials();
    
    return detectedCount;
  }

  // üìù ENREGISTRER UN OBJET DANS UNE CAT√âGORIE
  registerObject(objectType, objectName, meshObject) {
    if (!this.objectsByType[objectType]) {
      console.warn(`üéõÔ∏è BloomControlCenter: Type d'objet inconnu: ${objectType}`);
      return;
    }

    // Sauvegarder mat√©riau original si pas d√©j√† fait
    if (!meshObject.userData.originalMaterial) {
      meshObject.userData.originalMaterial = meshObject.material.clone();
    }

    this.objectsByType[objectType].set(objectName, meshObject);
  }

  // üé® APPLIQUER MAT√âRIAUX INITIAUX
  applyInitialMaterials() {
    Object.keys(this.objectsByType).forEach(objectType => {
      // ‚úÖ CORRECTION : Utiliser configs sp√©cifiques si disponibles
      let config = this.materialConfigs[objectType];
      
      // Configuration sp√©ciale pour revealRings
      if (objectType === 'revealRings') {
        config = {
          emissive: 0xffaa00,      // Orange pour reveal
          emissiveIntensity: 0.5,
          metalness: 0.8,
          roughness: 0.2
        };
      }
      
      if (config) {
        this.objectsByType[objectType].forEach((meshObject) => {
          this.updateObjectMaterial(meshObject, config);
        });
      }
    });

    // ‚úÖ COORDINATION : Synchroniser avec SimpleBloomSystem si disponible
    if (this.renderingEngine) {
      this.syncGroupsWithRenderingEngine();
    }
  }

  // üîß METTRE √Ä JOUR MAT√âRIAU D'UN OBJET
  updateObjectMaterial(meshObject, materialConfig) {
    if (!meshObject.material) return;

    Object.keys(materialConfig).forEach(property => {
      const value = materialConfig[property];
      
      if (property === 'emissive') {
        if (!meshObject.material.emissive) {
          meshObject.material.emissive = new THREE.Color();
        }
        // üîß CORRIG√â: G√©rer √† la fois les valeurs hex num√©riques ET les cha√Ænes hex
        if (typeof value === 'string') {
          // G√©rer les cha√Ænes hex comme '#ff4444' ou 'ff4444'
          meshObject.material.emissive.set(value);
        } else {
          // G√©rer les valeurs hex num√©riques comme 0xff4444
          meshObject.material.emissive.setHex(value);
        }
      } else if (meshObject.material[property] !== undefined) {
        meshObject.material[property] = value;
      }
    });

    meshObject.material.needsUpdate = true;
  }

  // üîß MODIFIER PROPRI√âT√â D'UN TYPE D'OBJET
  setObjectTypeProperty(objectType, property, value) {
    // ‚úÖ SUPPRIM√â : Log pour r√©duire spam console
    
    if (!this.objectsByType[objectType]) {
      console.warn(`üîß Type d'objet inconnu: ${objectType}`);
      return;
    }

    // üéØ CORRECTION PRINCIPALE : Pr√©server mode s√©curit√© actuel
    const currentSecurityPreset = this.securityPresets[this.currentSecurityState];
    const securityConfig = currentSecurityPreset && currentSecurityPreset[objectType];
    
    this.objectsByType[objectType].forEach((meshObject) => {
      if (property === 'emissive') {
        if (!meshObject.material.emissive) {
          meshObject.material.emissive = new THREE.Color();
        }
        // üîß CORRIG√â: G√©rer √† la fois les valeurs hex num√©riques ET les cha√Ænes hex
        if (typeof value === 'string') {
          // G√©rer les cha√Ænes hex comme '#ff4444' ou 'ff4444'
          meshObject.material.emissive.set(value);
        } else {
          // G√©rer les valeurs hex num√©riques comme 0xff4444
          meshObject.material.emissive.setHex(value);
        }
      } else if (meshObject.material && meshObject.material[property] !== undefined) {
        meshObject.material[property] = value;
        
        // üõ°Ô∏è IMPORTANT : R√©appliquer couleur de s√©curit√© apr√®s changement d'intensit√©
        if (property === 'emissiveIntensity' && securityConfig && securityConfig.emissive) {
          if (!meshObject.material.emissive) {
            meshObject.material.emissive = new THREE.Color();
          }
          meshObject.material.emissive.setHex(securityConfig.emissive);
          // ‚úÖ SUPPRIM√â : Log pour r√©duire spam console
        }
      }
      
      // ‚úÖ CORRECTION : Toujours marquer needsUpdate
      if (meshObject.material) {
        meshObject.material.needsUpdate = true;
      }
    });

  }

  // üîí CHANGER √âTAT DE S√âCURIT√â - M√âTHODE PRINCIPALE
  setSecurityState(newState) {
    if (!this.securityPresets[newState]) {
      console.warn(`üîí √âtat de s√©curit√© inconnu: ${newState}`);
      return;
    }

    this.currentSecurityState = newState;
    const preset = this.securityPresets[newState];

    // ‚úÖ Appliquer preset √† tous les types d'objets
    Object.keys(preset).forEach(objectType => {
      const config = preset[objectType];
      
      this.objectsByType[objectType].forEach((meshObject) => {
        // üîß CORRECTION CRITIQUE: S'assurer que le mat√©riau supporte l'√©missif
        if (meshObject.material && !meshObject.material.emissive) {
          meshObject.material.emissive = new THREE.Color(0x000000);
        }
        
        // üîß FORCER la visibilit√© des √©missifs
        if (meshObject.material) {
          // Augmenter l'intensit√© √©missive pour la s√©curit√©
          // üîß BOOST SP√âCIAL pour NORMAL qui a des valeurs trop faibles
          const boostFactor = this.currentSecurityState === 'NORMAL' ? 10 : 5;
          const boostedConfig = {
            ...this.materialConfigs[objectType],
            ...config,
            emissiveIntensity: config.emissiveIntensity * boostFactor // üî• BOOST x10 pour NORMAL, x5 pour les autres
          };
          
          this.updateObjectMaterial(meshObject, boostedConfig);
        }
      });
    });

    // üîß FORCER le rafra√Æchissement des mat√©riaux et du rendu
    // Parcourir tous les objets pour forcer needsUpdate
    Object.values(this.objectsByType).forEach(objects => {
      objects.forEach(meshObject => {
        if (meshObject.material) {
          meshObject.material.needsUpdate = true;
          // Forcer aussi la mise √† jour de la g√©om√©trie si n√©cessaire
          if (meshObject.geometry && meshObject.geometry.attributes) {
            meshObject.geometry.attributes.position.needsUpdate = true;
          }
        }
      });
    });

    // üîß NOUVEAU: D√©clencher un √©v√©nement pour forcer le rendu
    if (window.renderer) {
      window.renderer.render(window.scene, window.camera);
    }

    // üîß FORCER le rafra√Æchissement complet du syst√®me bloom
    // Probl√®me identifi√© : le changement de couleur ne force pas la mise √† jour des mat√©riaux
    if (window.sceneStateController && window.sceneStateController.systems.simpleBloom) {
      const bloomSystem = window.sceneStateController.systems.simpleBloom;
      
      // üî• SOLUTION : Forcer la reconstruction compl√®te du bloom pass
      if (bloomSystem.bloomPass && bloomSystem.bloomPass.dispose) {
        // Ne pas disposer, mais forcer la recompilation des shaders
        bloomSystem.bloomPass.needsSwap = true;
      }
      
      // üî• FORCER le recalcul des uniformes du shader bloom
      if (bloomSystem.bloomPass && bloomSystem.bloomPass.uniforms) {
        Object.keys(bloomSystem.bloomPass.uniforms).forEach(key => {
          if (bloomSystem.bloomPass.uniforms[key]) {
            bloomSystem.bloomPass.uniforms[key].needsUpdate = true;
          }
        });
      }
      
      // üî• FORCER la mise √† jour imm√©diate du threshold pour d√©clencher le recalcul
      const currentThreshold = bloomSystem.bloomPass.threshold;
      bloomSystem.bloomPass.threshold = 0.001; // Force tr√®s bas
      setTimeout(() => {
        bloomSystem.bloomPass.threshold = currentThreshold;
        // Double force apr√®s 10ms pour s'assurer
        setTimeout(() => {
          if (window.renderer && window.scene && window.camera) {
            window.renderer.render(window.scene, window.camera);
          }
        }, 10);
      }, 5);
    }

    // üî• APPELER la m√©thode de for√ßage complet
    this.forceCompleteRefresh();
    
    console.log(`üîí Security state changed to ${newState} - materials forced to update`);
  }
  
  // üî• NOUVELLE M√âTHODE: Forcer le recalcul complet apr√®s changement de couleur
  forceCompleteRefresh() {
    console.log('üî• BloomControlCenter: Forcing complete refresh after color change');
    
    // Forcer needsUpdate sur TOUS les mat√©riaux avec reset √©missif
    Object.values(this.objectsByType).forEach(objects => {
      objects.forEach(meshObject => {
        if (meshObject.material && meshObject.material.emissive) {
          const currentEmissive = meshObject.material.emissive.clone();
          const currentIntensity = meshObject.material.emissiveIntensity || 0;
          
          // Reset temporaire puis restore pour forcer le recalcul
          meshObject.material.emissive.setRGB(0, 0, 0);
          meshObject.material.emissiveIntensity = 0;
          meshObject.material.needsUpdate = true;
          
          setTimeout(() => {
            meshObject.material.emissive.copy(currentEmissive);
            meshObject.material.emissiveIntensity = currentIntensity;
            meshObject.material.needsUpdate = true;
            
            // Force aussi la mise √† jour de la g√©om√©trie
            if (meshObject.geometry && meshObject.geometry.attributes) {
              Object.values(meshObject.geometry.attributes).forEach(attr => {
                if (attr.needsUpdate !== undefined) {
                  attr.needsUpdate = true;
                }
              });
            }
          }, 10);
        }
      });
    });
  }

  // üåü API POST-PROCESSING (pour connexion future)
  setPostProcessParameter(parameter, value) {
    if (this.postProcessConfig[parameter] !== undefined) {
      this.postProcessConfig[parameter] = value;
    } else if (parameter.startsWith('reveal_')) {
      // ‚úÖ NOUVEAU : Param√®tres sp√©cifiques pour reveal rings
      const realParam = parameter.replace('reveal_', '');
      if (!this.revealPostProcessConfig) {
        this.revealPostProcessConfig = {
          threshold: 0.3,
          strength: 1.5,
          radius: 1.0
        };
      }
      
      if (this.revealPostProcessConfig[realParam] !== undefined) {
        this.revealPostProcessConfig[realParam] = value;
      }
    }
  }

  // ‚úÖ CCS: Synchronisation depuis SceneStateController
  syncFromStateController(stateController) {
    if (!stateController || !stateController.state) return;
    
    const bloomState = stateController.state.bloom;
    if (bloomState) {
      // ‚úÖ SUPPRIM√â : Log de sync CCS pour r√©duire spam console
      
      // Synchroniser les param√®tres bloom globaux
      this.postProcessConfig.threshold = bloomState.threshold;
      this.postProcessConfig.strength = bloomState.strength;
      this.postProcessConfig.radius = bloomState.radius;
      
      // Propager vers le moteur de rendu
      if (this.renderingEngine && this.renderingEngine.updateBloom) {
        this.renderingEngine.updateBloom('threshold', bloomState.threshold);
        this.renderingEngine.updateBloom('strength', bloomState.strength);
        this.renderingEngine.updateBloom('radius', bloomState.radius);
      }
    }
  }

  // üîÑ UPDATE (pour animations futures)
  update(deltaTime) {
    this.animationTime += deltaTime;
    
    if (this.pulseEnabled && this.currentSecurityState === 'SCANNING') {
      this.updatePulseEffect();
    }
  }

  // üí´ EFFET PULSE (pr√©par√© pour le futur)
  updatePulseEffect() {
    const pulseIntensity = Math.sin(this.animationTime * 3) * 0.2 + 0.5;
    
    // Appliquer pulsation aux eye rings et iris en mode SCANNING
    if (this.currentSecurityState === 'SCANNING') {
      const baseIntensity = this.securityPresets.SCANNING.eyeRings.emissiveIntensity;
      this.setObjectTypeProperty('eyeRings', 'emissiveIntensity', baseIntensity * pulseIntensity);
      this.setObjectTypeProperty('iris', 'emissiveIntensity', baseIntensity * pulseIntensity);
    }
  }

  // üìä INFORMATIONS DEBUG
  getObjectsInfo() {
    const info = {};
    Object.keys(this.objectsByType).forEach(type => {
      info[type] = {
        count: this.objectsByType[type].size,
        objects: Array.from(this.objectsByType[type].keys())
      };
    });
    return info;
  }

  // üìä INFORMATIONS CONFIG DEBUG
  getConfigInfo() {
    return {
      securityState: this.currentSecurityState,
      postProcessConfig: this.postProcessConfig,
      revealPostProcessConfig: this.revealPostProcessConfig || null,
      objectGroups: {
        iris: this.objectsByType.iris.size,
        eyeRings: this.objectsByType.eyeRings.size,
        magicRings: this.objectsByType.magicRings.size,
        arms: this.objectsByType.arms.size
      },
      renderingEngine: this.renderingEngine ? 'Connected' : 'Not Connected'
    };
  }

  // ‚úÖ COORDINATION : Interface unifi√©e bloom pour V3Scene avec support groupes
  setBloomParameter(param, value, groupName = null) {
    if (this.renderingEngine && this.renderingEngine.updateBloom) {
      if (groupName) {
        // ‚úÖ NOUVEAU : Param√®tres sp√©cifiques par groupe
        
        // Stocker la valeur pour ce groupe sp√©cifiquement
        if (!this.groupBloomSettings) {
          this.groupBloomSettings = {
            iris: { threshold: 0.3, strength: 0.8, radius: 0.4 },
            eyeRings: { threshold: 0.4, strength: 0.6, radius: 0.3 }, 
            revealRings: { threshold: 0.43, strength: 0.80, radius: 0.36 },
            magicRings: { threshold: 0.3, strength: 0.6, radius: 0.3 },
            arms: { threshold: 0.5, strength: 0.4, radius: 0.2 }
          };
        }
        
        if (this.groupBloomSettings[groupName]) {
          this.groupBloomSettings[groupName][param] = value;
          // Pour l'instant, appliquer au syst√®me global (limitation technique)
          // TODO: Impl√©menter le selective bloom plus tard
          this.renderingEngine.updateBloom(param, value);
        }
      } else {
        // ‚úÖ ANCIEN : Param√®tre global (threshold, etc.)
        this.renderingEngine.updateBloom(param, value);
      }
      return true;
    } else {
      console.warn(`‚ö†Ô∏è BloomControlCenter: Aucun moteur de rendu connect√© pour ${param}=${value}`);
      return false;
    }
  }
  
  // ‚úÖ NOUVEAU : Obtenir les param√®tres d'un groupe
  getGroupBloomSettings(groupName) {
    if (!this.groupBloomSettings || !this.groupBloomSettings[groupName]) {
      return { threshold: 0.3, strength: 0.8, radius: 0.4 }; // Valeurs par d√©faut
    }
    return this.groupBloomSettings[groupName];
  }

  // ‚úÖ COORDINATION : Synchroniser objets bloom vers moteur de rendu
  syncWithRenderingEngine() {
    if (!this.renderingEngine) return;
    
    // ‚úÖ CORRECTION : Utiliser les m√©thodes qui existent dans SimpleBloomSystem
    // Synchroniser les groupes d'objets
    this.syncGroupsWithRenderingEngine();
  }
  
  // ‚úÖ NOUVEAU : Synchroniser groupes avec SimpleBloomSystem
  syncGroupsWithRenderingEngine() {
    if (!this.renderingEngine) return;
    
    // Enregistrer les objets dans SimpleBloomSystem par groupe
    Object.keys(this.objectsByType).forEach(groupName => {
      this.objectsByType[groupName].forEach((meshObject) => {
        if (this.renderingEngine.addToGroup) {
          this.renderingEngine.addToGroup(meshObject, groupName);
        }
      });
    });
  }

  // ‚úÖ HELPER : R√©cup√©rer tous objets bloom pour synchronisation
  getAllBloomObjects() {
    const allObjects = {};
    Object.keys(this.objectsByType).forEach(type => {
      this.objectsByType[type].forEach((object, name) => {
        allObjects[`${type}.${name}`] = object;
      });
    });
    return allObjects;
  }

  // üîÑ RESET VERS MAT√âRIAUX ORIGINAUX
  resetToOriginalMaterials() {
    Object.values(this.objectsByType).forEach(objectMap => {
      objectMap.forEach((meshObject) => {
        if (meshObject.userData.originalMaterial) {
          meshObject.material = meshObject.userData.originalMaterial.clone();
        }
      });
    });
    
  }

  // üóëÔ∏è NETTOYAGE
  dispose() {
    this.resetToOriginalMaterials();
    
    Object.keys(this.objectsByType).forEach(type => {
      this.objectsByType[type].clear();
    });
    
  }
}