// üîÑ Migration Progressive FrameSchedulerMachine - Atome D1
// Strat√©gie de coexistence et migration depuis l'ancien syst√®me

import { frameSchedulerMachine } from './machine';
import { interpret } from 'xstate';

// üéØ Feature Flag pour Migration Progressive
export const FRAME_SCHEDULER_FEATURE_FLAGS = {
  USE_XSTATE_FRAME_SCHEDULER: process.env.REACT_APP_USE_XSTATE_SCHEDULER === 'true',
  ENABLE_DUAL_MODE: process.env.REACT_APP_SCHEDULER_DUAL_MODE === 'true',
  ENABLE_PERFORMANCE_COMPARISON: process.env.REACT_APP_SCHEDULER_COMPARE === 'true',
  AUTO_FALLBACK: process.env.REACT_APP_SCHEDULER_AUTO_FALLBACK !== 'false',
  DEBUG_MIGRATION: process.env.NODE_ENV === 'development'
};

// üîÑ Gestionnaire de Migration
export class FrameSchedulerMigration {
  private xstateService: any = null;
  private legacySystem: any = null;
  private currentMode: string = 'legacy';
  private performanceComparison: any = null;
  private migrationStartTime: number | null = null;
  private fallbackCount: number = 0;
  private maxFallbackAttempts: number = 3;
  private legacyBackup: any = null;

  constructor() {
    this.initializeMigration();
  }

  // üöÄ Initialisation de la Migration
  initializeMigration() {
    if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
      console.log('üîÑ FrameScheduler Migration: Initializing...', {
        useXState: FRAME_SCHEDULER_FEATURE_FLAGS.USE_XSTATE_FRAME_SCHEDULER,
        dualMode: FRAME_SCHEDULER_FEATURE_FLAGS.ENABLE_DUAL_MODE,
        comparePerformance: FRAME_SCHEDULER_FEATURE_FLAGS.ENABLE_PERFORMANCE_COMPARISON
      });
    }

    // üìä D√©tection du syst√®me legacy existant
    this.detectLegacySystem();

    // üéØ Configuration du mode selon les feature flags
    if (FRAME_SCHEDULER_FEATURE_FLAGS.ENABLE_DUAL_MODE) {
      this.enableDualMode();
    } else if (FRAME_SCHEDULER_FEATURE_FLAGS.USE_XSTATE_FRAME_SCHEDULER) {
      this.enableXStateMode();
    } else {
      this.enableLegacyMode();
    }

    // üìä Setup comparaison de performance si activ√©e
    if (FRAME_SCHEDULER_FEATURE_FLAGS.ENABLE_PERFORMANCE_COMPARISON) {
      this.setupPerformanceComparison();
    }
  }

  // üîç D√©tection du Syst√®me Legacy
  detectLegacySystem() {
    try {
      // Recherche des patterns de l'ancien syst√®me
      const legacyIndicators = [
        () => (window as any).animationControllerRef,
        () => (window as any).eyeRotationRef,
        () => (window as any).particleSystemRef,
        () => typeof window.requestAnimationFrame !== 'undefined'
      ];

      const detectedIndicators = legacyIndicators.filter(check => {
        try {
          return check();
        } catch {
          return false;
        }
      });

      this.legacySystem = {
        detected: detectedIndicators.length > 0,
        indicators: detectedIndicators.length,
        hasRAF: typeof window.requestAnimationFrame !== 'undefined',
        hasControllers: !!((window as any).animationControllerRef || (window as any).eyeRotationRef)
      };

      if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
        console.log('üîç Legacy system detection:', this.legacySystem);
      }

    } catch (error) {
      console.warn('‚ö†Ô∏è Error detecting legacy system:', error);
      this.legacySystem = { detected: false, error: error.message };
    }
  }

  // üéØ Mode XState Pur
  enableXStateMode() {
    if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
      console.log('üéØ Enabling XState-only mode');
    }

    try {
      this.xstateService = interpret(frameSchedulerMachine as any, {
        devTools: FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION
      });

      this.xstateService.onTransition((state) => {
        if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
          console.log('üîÑ XState transition:', state.value);
        }

        // üö® Auto-fallback en cas d'erreur critique
        if (state.matches('error') && FRAME_SCHEDULER_FEATURE_FLAGS.AUTO_FALLBACK) {
          this.handleXStateFailure(state);
        }
      });

      this.xstateService.start();
      this.currentMode = 'xstate';
      this.migrationStartTime = performance.now();

      // üöÄ D√©marrage automatique
      this.xstateService.send('START_LOOP');

      console.log('‚úÖ XState FrameScheduler activated');

    } catch (error) {
      console.error('‚ùå Failed to enable XState mode:', error);
      this.fallbackToLegacy(error);
    }
  }

  // üìä Mode Dual (XState + Legacy en parall√®le)
  enableDualMode() {
    if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
      console.log('üìä Enabling dual mode (XState + Legacy)');
    }

    try {
      // üéØ Initialisation XState
      this.enableXStateMode();

      // üìä Pr√©servation du syst√®me legacy en parall√®le
      this.preserveLegacySystem();

      this.currentMode = 'dual';

      console.log('‚úÖ Dual mode activated');

    } catch (error) {
      console.error('‚ùå Failed to enable dual mode:', error);
      this.fallbackToLegacy(error);
    }
  }

  // üîÑ Mode Legacy Pur
  enableLegacyMode() {
    if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
      console.log('üîÑ Maintaining legacy mode');
    }

    this.currentMode = 'legacy';
    // Le syst√®me legacy continue de fonctionner normalement
    console.log('‚úÖ Legacy mode maintained');
  }

  // üõ°Ô∏è Pr√©servation du Syst√®me Legacy
  preserveLegacySystem() {
    try {
      // Sauvegarde des r√©f√©rences importantes
      this.legacyBackup = {
        animationController: (window as any).animationControllerRef,
        eyeRotation: (window as any).eyeRotationRef,
        particleSystem: (window as any).particleSystemRef,
        pbrLighting: (window as any).pbrLightingController,
        bloom: (window as any).bloomSystem
      };

      if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
        console.log('üõ°Ô∏è Legacy system preserved:', Object.keys(this.legacyBackup));
      }

    } catch (error) {
      console.warn('‚ö†Ô∏è Error preserving legacy system:', error);
    }
  }

  // üö® Gestion d'√âchec XState
  handleXStateFailure(errorState) {
    this.fallbackCount++;

    console.error(`üö® XState failure #${this.fallbackCount}:`, {
      state: errorState.value,
      error: errorState.context.error,
      attempts: this.fallbackCount,
      maxAttempts: this.maxFallbackAttempts
    });

    if (this.fallbackCount >= this.maxFallbackAttempts) {
      console.error('üö® Maximum fallback attempts reached, switching to legacy mode');
      this.fallbackToLegacy(new Error('Maximum XState failure attempts reached'));
    } else {
      // Tentative de r√©cup√©ration
      setTimeout(() => {
        if (this.xstateService) {
          this.xstateService.send('START_LOOP');
        }
      }, 1000 * this.fallbackCount); // Backoff progressif
    }
  }

  // üîÑ Fallback vers Legacy
  fallbackToLegacy(error) {
    console.warn('üîÑ Falling back to legacy system:', error.message);

    try {
      // üõë Arr√™t du service XState
      if (this.xstateService) {
        this.xstateService.stop();
        this.xstateService = null;
      }

      // üîÑ Restauration du syst√®me legacy
      this.restoreLegacySystem();

      this.currentMode = 'legacy';

      // üìä T√©l√©m√©trie de fallback
      this.reportFallback(error);

      console.log('‚úÖ Successfully fell back to legacy system');

    } catch (fallbackError) {
      console.error('‚ùå Critical: Fallback to legacy failed:', fallbackError);
    }
  }

  // üîÑ Restauration du Syst√®me Legacy
  restoreLegacySystem() {
    if (this.legacyBackup) {
      try {
        // Restauration des r√©f√©rences
        Object.entries(this.legacyBackup).forEach(([key, value]) => {
          if (value) {
            window[key] = value;
          }
        });

        if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
          console.log('üîÑ Legacy system restored');
        }

      } catch (error) {
        console.error('‚ùå Error restoring legacy system:', error);
      }
    }
  }

  // üìä Setup Comparaison de Performance
  setupPerformanceComparison() {
    this.performanceComparison = {
      xstate: {
        frameCount: 0,
        totalFrameTime: 0,
        errors: 0,
        recoveries: 0
      },
      legacy: {
        frameCount: 0,
        totalFrameTime: 0,
        errors: 0
      },
      startTime: performance.now()
    };

    // üìä Monitoring p√©riodique
    setInterval(() => {
      this.reportPerformanceComparison();
    }, 10000); // Rapport toutes les 10 secondes

    if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
      console.log('üìä Performance comparison enabled');
    }
  }

  // üìä Rapport de Comparaison
  reportPerformanceComparison() {
    if (!this.performanceComparison) return;

    const duration = performance.now() - this.performanceComparison.startTime;
    const xstate = this.performanceComparison.xstate;
    const legacy = this.performanceComparison.legacy;

    const report = {
      duration: duration / 1000, // en secondes
      xstate: {
        fps: xstate.frameCount / (duration / 1000),
        avgFrameTime: xstate.frameCount > 0 ? xstate.totalFrameTime / xstate.frameCount : 0,
        errorRate: xstate.errors / Math.max(xstate.frameCount, 1),
        recoveryRate: xstate.recoveries / Math.max(xstate.errors, 1)
      },
      legacy: {
        fps: legacy.frameCount / (duration / 1000),
        avgFrameTime: legacy.frameCount > 0 ? legacy.totalFrameTime / legacy.frameCount : 0,
        errorRate: legacy.errors / Math.max(legacy.frameCount, 1)
      }
    };

    console.log('üìä Performance Comparison Report:', report);

    // üéØ Recommandation automatique
    if (report.xstate.fps > report.legacy.fps * 1.1 && report.xstate.errorRate < 0.01) {
      console.log('‚úÖ Recommendation: XState system performing better');
    } else if (report.legacy.fps > report.xstate.fps * 1.1 || report.xstate.errorRate > 0.05) {
      console.log('‚ö†Ô∏è Recommendation: Consider staying with legacy system');
    }
  }

  // üì° Rapport de Fallback
  reportFallback(error) {
    const report = {
      timestamp: new Date().toISOString(),
      error: error.message,
      fallbackCount: this.fallbackCount,
      migrationDuration: this.migrationStartTime ? performance.now() - this.migrationStartTime : null,
      legacySystemAvailable: !!this.legacySystem?.detected,
      userAgent: navigator.userAgent
    };

    console.warn('üì° Fallback Report:', report);

    // Ici on pourrait envoyer √† un service de t√©l√©m√©trie
    // sendTelemetry('frameScheduler.fallback', report);
  }

  // üîç API Publique pour Monitoring
  getStatus() {
    return {
      currentMode: this.currentMode,
      xstateActive: !!this.xstateService && this.xstateService.status === 1,
      legacyDetected: this.legacySystem?.detected,
      fallbackCount: this.fallbackCount,
      migrationDuration: this.migrationStartTime ? performance.now() - this.migrationStartTime : null,
      performanceComparison: this.performanceComparison
    };
  }

  // üéÆ Contr√¥les Manuels
  switchToXState() {
    if (this.currentMode !== 'xstate') {
      console.log('üéØ Manual switch to XState mode');
      this.enableXStateMode();
    }
  }

  switchToLegacy() {
    if (this.currentMode !== 'legacy') {
      console.log('üîÑ Manual switch to legacy mode');
      this.fallbackToLegacy(new Error('Manual switch to legacy'));
    }
  }

  // üßπ Nettoyage
  cleanup() {
    if (this.xstateService) {
      this.xstateService.stop();
    }

    if (FRAME_SCHEDULER_FEATURE_FLAGS.DEBUG_MIGRATION) {
      console.log('üßπ FrameScheduler migration cleaned up');
    }
  }
}

// üåç Instance Globale
let migrationManager = null;

export const getFrameSchedulerMigration = () => {
  if (!migrationManager) {
    migrationManager = new FrameSchedulerMigration();
  }
  return migrationManager;
};

// üéØ Helper pour Hook React
export const useMigrationStatus = () => {
  const manager = getFrameSchedulerMigration();
  return manager.getStatus();
};