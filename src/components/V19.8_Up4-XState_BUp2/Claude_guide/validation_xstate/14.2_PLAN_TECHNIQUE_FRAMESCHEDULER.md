# üèóÔ∏è PLAN TECHNIQUE COMPLET - FRAMESCHEDULERMACHINE

## üéØ Vue d'Ensemble

**Bas√© sur 6 recherches approfondies**, ce plan technique d√©finit l'architecture compl√®te de la FrameSchedulerMachine XState qui remplacera le syst√®me requestAnimationFrame actuel tout en garantissant :
- ‚ö° **Performance 60fps** stable
- üõ°Ô∏è **Robustesse** maximale (gestion d'erreurs WebGL)
- üîÑ **Migration progressive** sans risque
- üìä **Monitoring** production int√©gr√©

## üìã ARCHITECTURE TECHNIQUE

### üèõÔ∏è **Structure de la Machine Principale**

```typescript
// machines/frameSchedulerMachine.ts
import { createMachine, assign, interpret } from 'xstate';
import { THREE } from 'three';

interface FrameSchedulerContext {
  // Performance Monitoring
  frameCount: number;
  averageFrameTime: number;
  slowFrameCount: number;
  lastFrameTime: number;

  // Render State
  clock: THREE.Clock | null;
  animationId: number | null;
  isRunning: boolean;

  // Systems Registry
  systems: Array<{
    id: string;
    updateFn: (deltaTime: number) => void;
    priority: number;
    enabled: boolean;
  }>;

  // Error Recovery
  errorCount: number;
  lastError: Error | null;
  contextLostCount: number;

  // Feature Flags
  useNewFrameScheduler: boolean;
  enablePerformanceMonitoring: boolean;
  enableErrorRecovery: boolean;
}

type FrameSchedulerEvent =
  | { type: 'START' }
  | { type: 'STOP' }
  | { type: 'PAUSE' }
  | { type: 'RESUME' }
  | { type: 'FRAME_TICK'; deltaTime: number; timestamp: number }
  | { type: 'RENDER_ERROR'; error: Error }
  | { type: 'CONTEXT_LOST' }
  | { type: 'CONTEXT_RESTORED' }
  | { type: 'REGISTER_SYSTEM'; system: SystemConfig }
  | { type: 'UNREGISTER_SYSTEM'; systemId: string }
  | { type: 'PERFORMANCE_WARNING'; frameTime: number }
  | { type: 'RECOVERY_COMPLETE' };

const frameSchedulerMachine = createMachine<FrameSchedulerContext, FrameSchedulerEvent>({
  id: 'frameScheduler',
  initial: 'idle',

  context: {
    frameCount: 0,
    averageFrameTime: 16.67,
    slowFrameCount: 0,
    lastFrameTime: 0,
    clock: null,
    animationId: null,
    isRunning: false,
    systems: [],
    errorCount: 0,
    lastError: null,
    contextLostCount: 0,
    useNewFrameScheduler: true,
    enablePerformanceMonitoring: true,
    enableErrorRecovery: true
  },

  states: {
    idle: {
      entry: 'initializeClock',
      on: {
        START: 'starting',
        REGISTER_SYSTEM: {
          actions: 'registerSystem'
        }
      }
    },

    starting: {
      invoke: {
        src: 'initializeRenderLoop',
        onDone: 'running',
        onError: {
          target: 'error',
          actions: 'logInitError'
        }
      }
    },

    running: {
      entry: 'startPerformanceMonitoring',
      invoke: {
        src: 'frameLoopService',
        onError: {
          target: 'error',
          actions: 'logRenderError'
        }
      },

      on: {
        FRAME_TICK: {
          actions: [
            'updatePerformanceMetrics',
            'updateAllSystems',
            'checkPerformanceThresholds'
          ]
        },

        STOP: 'stopping',
        PAUSE: 'paused',

        RENDER_ERROR: {
          target: 'error',
          actions: 'handleRenderError'
        },

        CONTEXT_LOST: {
          target: 'contextLost',
          actions: 'handleContextLost'
        },

        PERFORMANCE_WARNING: {
          actions: 'logPerformanceWarning'
        },

        REGISTER_SYSTEM: {
          actions: 'registerSystem'
        },

        UNREGISTER_SYSTEM: {
          actions: 'unregisterSystem'
        }
      }
    },

    paused: {
      entry: 'pauseRenderLoop',
      on: {
        RESUME: 'running',
        STOP: 'stopping'
      }
    },

    stopping: {
      entry: 'stopRenderLoop',
      invoke: {
        src: 'cleanupResources',
        onDone: 'idle'
      }
    },

    error: {
      entry: 'logError',
      after: {
        1000: [
          {
            target: 'recovering',
            cond: 'canRecover'
          },
          {
            target: 'fatal',
            actions: 'notifyFatalError'
          }
        ]
      },

      on: {
        START: {
          target: 'recovering',
          cond: 'canRecover'
        }
      }
    },

    recovering: {
      entry: 'startRecovery',
      invoke: {
        src: 'recoverRenderLoop',
        onDone: {
          target: 'running',
          actions: 'logRecoverySuccess'
        },
        onError: {
          target: 'fatal',
          actions: 'logRecoveryFailure'
        }
      }
    },

    contextLost: {
      entry: 'handleWebGLContextLost',
      on: {
        CONTEXT_RESTORED: {
          target: 'contextRecovering',
          actions: 'prepareContextRecovery'
        }
      }
    },

    contextRecovering: {
      invoke: {
        src: 'restoreWebGLContext',
        onDone: {
          target: 'running',
          actions: 'logContextRecovery'
        },
        onError: {
          target: 'error',
          actions: 'logContextRecoveryError'
        }
      }
    },

    fatal: {
      entry: 'handleFatalError',
      type: 'final'
    }
  }
});
```

### üîß **Services (Invoked Functions)**

```typescript
// services/frameSchedulerServices.ts
export const frameSchedulerServices = {
  frameLoopService: (context: FrameSchedulerContext) => (sendBack: any) => {
    let animationId: number | null = null;
    const clock = context.clock || new THREE.Clock();

    const loop = (timestamp: number) => {
      try {
        const deltaTime = clock.getDelta();

        // Send frame tick to machine
        sendBack({
          type: 'FRAME_TICK',
          deltaTime,
          timestamp
        });

        // Schedule next frame
        animationId = requestAnimationFrame(loop);

      } catch (error) {
        // Error handling - stop loop and notify machine
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }

        sendBack({
          type: 'RENDER_ERROR',
          error
        });
      }
    };

    // Start the loop
    animationId = requestAnimationFrame(loop);

    // Cleanup function
    return () => {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    };
  },

  initializeRenderLoop: async (context: FrameSchedulerContext) => {
    // Initialize Three.js clock
    const clock = new THREE.Clock();

    // Setup WebGL context loss handlers
    const canvas = document.querySelector('canvas');
    if (canvas) {
      canvas.addEventListener('webglcontextlost', (event) => {
        event.preventDefault();
        // Will be handled by machine
      });

      canvas.addEventListener('webglcontextrestored', () => {
        // Will be handled by machine
      });
    }

    return { clock };
  },

  recoverRenderLoop: async (context: FrameSchedulerContext) => {
    // Reset error state
    const clock = new THREE.Clock();

    // Re-initialize systems that may have failed
    for (const system of context.systems) {
      if (system.enabled) {
        try {
          // Call system initialization if available
          if ('initialize' in system) {
            await (system as any).initialize();
          }
        } catch (error) {
          console.warn(`Failed to reinitialize system ${system.id}:`, error);
        }
      }
    }

    return { clock };
  },

  restoreWebGLContext: async (context: FrameSchedulerContext) => {
    // WebGL context recovery logic
    const renderer = window.renderer; // Access global renderer

    if (renderer) {
      // Force WebGL context recreation
      renderer.forceContextRestore();

      // Reinitialize all WebGL resources
      // This would typically involve recreating shaders, textures, etc.
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    return { contextRestored: true };
  },

  cleanupResources: async (context: FrameSchedulerContext) => {
    // Cleanup any remaining resources
    if (context.animationId) {
      cancelAnimationFrame(context.animationId);
    }

    // Dispose of Three.js clock
    if (context.clock) {
      context.clock = null;
    }

    return { cleaned: true };
  }
};
```

### ‚öôÔ∏è **Actions (State Machine Actions)**

```typescript
// actions/frameSchedulerActions.ts
export const frameSchedulerActions = {
  initializeClock: assign({
    clock: () => new THREE.Clock(),
    isRunning: false
  }),

  updatePerformanceMetrics: assign((context, event) => {
    if (event.type !== 'FRAME_TICK') return context;

    const frameTime = event.deltaTime * 1000; // Convert to ms
    const slowFrame = frameTime > 20; // Threshold for slow frame

    return {
      ...context,
      frameCount: context.frameCount + 1,
      lastFrameTime: frameTime,
      averageFrameTime: (context.averageFrameTime * 0.9) + (frameTime * 0.1), // Exponential moving average
      slowFrameCount: context.slowFrameCount + (slowFrame ? 1 : 0)
    };
  }),

  updateAllSystems: (context, event) => {
    if (event.type !== 'FRAME_TICK') return;

    // Sort systems by priority (lower number = higher priority)
    const sortedSystems = [...context.systems]
      .filter(system => system.enabled)
      .sort((a, b) => a.priority - b.priority);

    // Update each system in order
    sortedSystems.forEach(system => {
      try {
        system.updateFn(event.deltaTime);
      } catch (error) {
        console.error(`System ${system.id} update failed:`, error);
        // Could send error event to machine if needed
      }
    });
  },

  checkPerformanceThresholds: (context, event) => {
    if (event.type !== 'FRAME_TICK') return;

    const frameTime = event.deltaTime * 1000;

    if (frameTime > 25) { // Very slow frame
      // Send performance warning
      return {
        type: 'PERFORMANCE_WARNING',
        frameTime
      };
    }
  },

  registerSystem: assign((context, event) => {
    if (event.type !== 'REGISTER_SYSTEM') return context;

    const existingIndex = context.systems.findIndex(s => s.id === event.system.id);

    if (existingIndex >= 0) {
      // Update existing system
      const newSystems = [...context.systems];
      newSystems[existingIndex] = event.system;
      return { ...context, systems: newSystems };
    } else {
      // Add new system
      return {
        ...context,
        systems: [...context.systems, event.system]
      };
    }
  }),

  unregisterSystem: assign((context, event) => {
    if (event.type !== 'UNREGISTER_SYSTEM') return context;

    return {
      ...context,
      systems: context.systems.filter(s => s.id !== event.systemId)
    };
  }),

  handleRenderError: assign((context, event) => {
    if (event.type !== 'RENDER_ERROR') return context;

    return {
      ...context,
      errorCount: context.errorCount + 1,
      lastError: event.error
    };
  }),

  handleContextLost: assign((context) => ({
    ...context,
    contextLostCount: context.contextLostCount + 1,
    isRunning: false
  })),

  logError: (context, event) => {
    console.error('FrameScheduler error:', context.lastError);

    // Send telemetry if available
    if (window.telemetry) {
      window.telemetry.track('frame_scheduler_error', {
        error: context.lastError?.message,
        errorCount: context.errorCount,
        frameCount: context.frameCount
      });
    }
  },

  logPerformanceWarning: (context, event) => {
    if (event.type !== 'PERFORMANCE_WARNING') return;

    console.warn(`Slow frame detected: ${event.frameTime.toFixed(2)}ms`);

    // Telemetry
    if (window.telemetry) {
      window.telemetry.track('slow_frame', {
        frameTime: event.frameTime,
        averageFrameTime: context.averageFrameTime,
        slowFrameCount: context.slowFrameCount
      });
    }
  },

  startPerformanceMonitoring: (context) => {
    if (context.enablePerformanceMonitoring) {
      console.log('üéØ FrameScheduler performance monitoring started');
    }
  },

  pauseRenderLoop: assign({
    isRunning: false
  }),

  stopRenderLoop: assign({
    isRunning: false,
    frameCount: 0,
    slowFrameCount: 0
  }),

  startRecovery: (context) => {
    console.log('üîÑ Starting FrameScheduler recovery...');
  },

  logRecoverySuccess: (context) => {
    console.log('‚úÖ FrameScheduler recovery successful');
  },

  logRecoveryFailure: (context, event) => {
    console.error('‚ùå FrameScheduler recovery failed:', event.data);
  },

  handleFatalError: (context) => {
    console.error('üíÄ FrameScheduler fatal error - manual intervention required');

    // Notify user/system of fatal error
    if (window.notify) {
      window.notify.error('Render system encountered a fatal error');
    }
  }
};
```

### üõ°Ô∏è **Guards (Conditions)**

```typescript
// guards/frameSchedulerGuards.ts
export const frameSchedulerGuards = {
  canRecover: (context: FrameSchedulerContext) => {
    // Allow recovery if error count is below threshold
    return context.errorCount < 3;
  },

  isPerformanceAcceptable: (context: FrameSchedulerContext) => {
    // Check if average frame time is within acceptable range
    return context.averageFrameTime < 20; // 50fps minimum
  },

  hasWebGLSupport: () => {
    // Check WebGL support
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    return !!gl;
  },

  isProductionEnvironment: () => {
    return process.env.NODE_ENV === 'production';
  }
};
```

## üîÑ STRAT√âGIE DE MIGRATION PROGRESSIVE

### üìã **Phase 1: Setup et Feature Flags**

```typescript
// config/featureFlags.ts
export const FRAME_SCHEDULER_FLAGS = {
  USE_XSTATE_SCHEDULER: process.env.NODE_ENV === 'development' ||
                        (Math.random() < 0.1), // 10% rollout

  ENABLE_PERFORMANCE_MONITORING: true,
  ENABLE_ERROR_RECOVERY: true,
  ENABLE_WEBGL_RECOVERY: true,

  // Debug flags
  ENABLE_XSTATE_DEVTOOLS: process.env.NODE_ENV === 'development',
  VERBOSE_LOGGING: process.env.NODE_ENV === 'development'
};

// migration/FrameSchedulerBridge.ts
export class FrameSchedulerBridge {
  private xstateService: any = null;
  private legacyRenderLoop: any = null;

  constructor() {
    if (FRAME_SCHEDULER_FLAGS.USE_XSTATE_SCHEDULER) {
      this.initializeXState();
    } else {
      this.initializeLegacy();
    }
  }

  private initializeXState() {
    this.xstateService = interpret(frameSchedulerMachine);
    this.xstateService.start();
    console.log('üöÄ Using XState FrameScheduler');
  }

  private initializeLegacy() {
    // Keep existing render loop as fallback
    this.legacyRenderLoop = window.existingRenderLoop;
    console.log('üîô Using Legacy FrameScheduler');
  }

  start() {
    if (this.xstateService) {
      this.xstateService.send('START');
    } else if (this.legacyRenderLoop) {
      this.legacyRenderLoop.start();
    }
  }

  stop() {
    if (this.xstateService) {
      this.xstateService.send('STOP');
    } else if (this.legacyRenderLoop) {
      this.legacyRenderLoop.stop();
    }
  }

  registerSystem(system: SystemConfig) {
    if (this.xstateService) {
      this.xstateService.send({ type: 'REGISTER_SYSTEM', system });
    } else if (this.legacyRenderLoop) {
      this.legacyRenderLoop.addSystem(system);
    }
  }
}
```

### üìã **Phase 2: Int√©gration avec les Syst√®mes Existants**

```typescript
// integration/SystemsIntegration.ts
export class SystemsIntegration {
  static migrateExistingSystems(scheduler: FrameSchedulerBridge) {
    // Animation Controller
    scheduler.registerSystem({
      id: 'animationController',
      updateFn: (deltaTime) => {
        window.animationControllerRef.current?.update(deltaTime);
      },
      priority: 1,
      enabled: true
    });

    // Eye Ring Rotation
    scheduler.registerSystem({
      id: 'eyeRotation',
      updateFn: (deltaTime) => {
        window.eyeRotationRef.current?.updateEyeRotation(deltaTime);
      },
      priority: 2,
      enabled: true
    });

    // Model Rotation Manager
    scheduler.registerSystem({
      id: 'modelRotation',
      updateFn: (deltaTime) => {
        window.modelRotationManagerRef.current?.update(deltaTime);
      },
      priority: 3,
      enabled: true
    });

    // Revelation System
    scheduler.registerSystem({
      id: 'revelation',
      updateFn: () => {
        window.revelationSystemRef.current?.updateRevelation();
      },
      priority: 4,
      enabled: true
    });

    // Bloom Control Center
    scheduler.registerSystem({
      id: 'bloomControl',
      updateFn: (deltaTime) => {
        window.bloomControlCenterRef.current?.update(deltaTime);
      },
      priority: 5,
      enabled: true
    });

    // Object Transition Manager
    scheduler.registerSystem({
      id: 'objectTransition',
      updateFn: (deltaTime) => {
        window.objectTransitionRef.current?.update(deltaTime);
      },
      priority: 6,
      enabled: true
    });

    // Floating Space
    scheduler.registerSystem({
      id: 'floatingSpace',
      updateFn: () => {
        window.floatingSpace?.update();
      },
      priority: 7,
      enabled: true
    });

    // Particle System
    scheduler.registerSystem({
      id: 'particleSystem',
      updateFn: () => {
        window.particleSystemControllerRef.current?.update();
      },
      priority: 8,
      enabled: true
    });
  }
}
```

## üìä MONITORING ET DEBUGGING

### üîç **Production Monitoring**

```typescript
// monitoring/FrameSchedulerMonitor.ts
export class FrameSchedulerMonitor {
  private metrics = {
    frameCount: 0,
    slowFrames: 0,
    errors: 0,
    recoveries: 0,
    contextLosses: 0
  };

  constructor(private service: any) {
    this.setupMonitoring();
  }

  private setupMonitoring() {
    this.service.onTransition((state: any) => {
      this.trackStateTransition(state);
    });

    // Performance monitoring
    setInterval(() => {
      this.reportMetrics();
    }, 30000); // Report every 30 seconds
  }

  private trackStateTransition(state: any) {
    const { context, value } = state;

    // Track frame metrics
    this.metrics.frameCount = context.frameCount;
    this.metrics.slowFrames = context.slowFrameCount;
    this.metrics.errors = context.errorCount;
    this.metrics.contextLosses = context.contextLostCount;

    // Log state changes
    if (value === 'error') {
      console.error('FrameScheduler entered error state');
    } else if (value === 'recovering') {
      console.log('FrameScheduler starting recovery');
      this.metrics.recoveries++;
    }
  }

  private reportMetrics() {
    if (window.telemetry) {
      window.telemetry.track('frame_scheduler_metrics', {
        ...this.metrics,
        timestamp: Date.now()
      });
    }

    // Log performance summary
    if (this.metrics.frameCount > 0) {
      const slowFrameRate = (this.metrics.slowFrames / this.metrics.frameCount) * 100;
      console.log(`üìä FrameScheduler: ${slowFrameRate.toFixed(1)}% slow frames`);
    }
  }
}
```

### üõ†Ô∏è **Development DevTools**

```typescript
// devtools/FrameSchedulerDevTools.ts
export class FrameSchedulerDevTools {
  constructor(private service: any) {
    if (FRAME_SCHEDULER_FLAGS.ENABLE_XSTATE_DEVTOOLS) {
      this.setupXStateInspector();
    }

    this.setupCustomDevTools();
  }

  private async setupXStateInspector() {
    const { inspect } = await import('@xstate/inspect');

    inspect({
      iframe: false,
      url: 'https://stately.ai/viz?inspect'
    });
  }

  private setupCustomDevTools() {
    // Add global debug methods
    (window as any).__frameSchedulerDebug = {
      getMetrics: () => this.service.state.context,
      pauseScheduler: () => this.service.send('PAUSE'),
      resumeScheduler: () => this.service.send('RESUME'),
      triggerError: () => this.service.send({
        type: 'RENDER_ERROR',
        error: new Error('Test error')
      }),
      showStateMachine: () => console.log(this.service.state.value)
    };

    console.log('üõ†Ô∏è FrameScheduler DevTools available at window.__frameSchedulerDebug');
  }
}
```

## üöÄ PLAN D'IMPL√âMENTATION

### üìÖ **Timeline de D√©veloppement**

#### **Semaine 1: Fondations**
- [ ] Cr√©er la structure de base FrameSchedulerMachine
- [ ] Impl√©menter les services de base (frameLoopService)
- [ ] Setup feature flags et bridge
- [ ] Tests unitaires de base

#### **Semaine 2: Int√©gration**
- [ ] Int√©grer les 8 syst√®mes existants
- [ ] Impl√©menter la gestion d'erreurs
- [ ] Setup monitoring et t√©l√©m√©trie
- [ ] Tests d'int√©gration

#### **Semaine 3: Robustesse**
- [ ] Impl√©menter WebGL context recovery
- [ ] Optimisations performance
- [ ] Tests de charge et stress
- [ ] Documentation compl√®te

#### **Semaine 4: D√©ploiement**
- [ ] Feature flag rollout progressif (5% ‚Üí 25% ‚Üí 50%)
- [ ] Monitoring production
- [ ] Corrections bugs
- [ ] Rollout 100%

### ‚úÖ **Crit√®res de Succ√®s**

#### **Performance**
- [ ] 60fps stable maintenu avec 8 syst√®mes
- [ ] <1% de slow frames (>20ms)
- [ ] Z√©ro memory leaks d√©tect√©s
- [ ] Recovery automatique des erreurs

#### **Robustesse**
- [ ] Gestion WebGL context lost/restored
- [ ] Recovery automatique des crashes
- [ ] Fallback vers legacy syst√®me
- [ ] Monitoring et alertes fonctionnels

#### **Migration**
- [ ] Coexistence parfaite legacy/nouveau
- [ ] Rollback instantan√© possible
- [ ] Z√©ro r√©gression fonctionnelle
- [ ] Documentation compl√®te

## üéØ PROCHAINES √âTAPES

1. **Valider le plan** avec l'√©quipe
2. **Cr√©er le repository** structure
3. **Impl√©menter** FrameSchedulerMachine de base
4. **Tester** avec un syst√®me simple
5. **It√©rer** et am√©liorer

**Ce plan technique est pr√™t pour l'impl√©mentation !** üöÄ