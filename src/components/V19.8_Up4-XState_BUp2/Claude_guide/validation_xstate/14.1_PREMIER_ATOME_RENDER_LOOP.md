# üéØ PREMIER ATOME: RENDER LOOP ‚Üí FRAMESCHEDULER

## üöÄ CHOIX STRAT√âGIQUE

**Atome D1 (Render Loop ‚Üí FrameSchedulerMachine)** choisi comme point de d√©part car :
- üèóÔ∏è **Fondation architecturale** - Impact sur tous les autres syst√®mes
- ‚ö° **Performance critique** - 60fps, 8 syst√®mes √† coordonner
- üîÑ **Pattern r√©utilisable** - Servira pour tous les autres atomes

## üîç RECHERCHES REQUISES

### üìã Recherche 1: Architecture Render Loop Actuelle
**Mots-cl√©s pour recherche:**
- `useFrame`
- `requestAnimationFrame`
- `deltaTime`
- `update`
- `render loop`
- `animation controller`

**Phrases-cl√©s sp√©cifiques:**
- "startRenderLoop"
- "animationControllerRef.current?.update"
- "useFrame hook"
- "deltaTime calculation"

**Objectif:** Comprendre l'impl√©mentation actuelle compl√®te

### üìã Recherche 2: Int√©gration XState avec Render Loop
**Mots-cl√©s pour recherche:**
- `XState invoke`
- `XState services`
- `React useFrame`
- `frame scheduling`
- `XState React integration`

**Phrases-cl√©s sp√©cifiques:**
- "XState with requestAnimationFrame"
- "XState invoke service continuous"
- "React Three Fiber useFrame XState"
- "XState frame loop pattern"

**Objectif:** Patterns d'int√©gration XState + render loop

### üìã Recherche 3: Performance et Optimisation
**Mots-cl√©s pour recherche:**
- `React Three Fiber performance`
- `useFrame optimization`
- `XState performance`
- `frame scheduling`

**Phrases-cl√©s sp√©cifiques:**
- "useFrame performance best practices"
- "XState service performance"
- "frame scheduling optimization"
- "React Three Fiber 60fps"

**Objectif:** Optimisations et bonnes pratiques

## üîÑ PROCESS COLLABORATIF

### √âtapes
1. **Toi:** Lancer les 3 recherches avec ces mots-cl√©s
2. **Toi:** Me donner TOUS les r√©sultats trouv√©s
3. **Moi:** Analyser et compiler toutes les infos
4. **Moi:** D√©finir le plan technique pr√©cis FrameSchedulerMachine
5. **Ensemble:** Valider la faisabilit√© du plan
6. **Moi:** Coder la FrameSchedulerMachine
7. **Ensemble:** Tester et valider l'impl√©mentation
8. **Moi:** Documenter pour les autres atomes

### R√©sultats Attendus
Apr√®s tes recherches, je pourrai cr√©er :
- ‚úÖ **FrameSchedulerMachine** compl√®te et optimis√©e
- ‚úÖ **Patterns r√©utilisables** pour les autres atomes
- ‚úÖ **Architecture solide** pour tout le syst√®me XState

## üéØ LIVRABLE FINAL ATOME D1

```javascript
// Preview de ce qu'on va cr√©er
const frameSchedulerMachine = createMachine({
  id: 'frameScheduler',

  states: {
    idle: { /* ... */ },
    running: {
      invoke: {
        src: 'frameLoop', // Service bas√© sur tes recherches
        // Coordination des 8 syst√®mes
      }
    }
  }
});
```

## üöÄ READY ?

**Lance les recherches et ram√®ne-moi tout !**

Ensuite on cr√©e ensemble la meilleure FrameSchedulerMachine possible. üí™

---

## üîç PR√âCISIONS TECHNIQUES POUR LA RECHERCHE

### üìã R√©ponses aux Questions Techniques

#### 1. Syst√®me de Render Loop Actuel ‚úÖ
- **NON, PAS React Three Fiber** - Syst√®me custom bas√© sur requestAnimationFrame
- **8 syst√®mes coordonn√©s** via un callback unique dans startRenderLoop (V3Scene.jsx)
- **Structure exacte** : useThreeScene.js lignes 207-241 avec THREE.Clock pour deltaTime

#### 2. Architecture Multi-Syst√®mes ‚úÖ
- **OUI, gestion synchronis√©e** de tous les syst√®mes dans la FrameSchedulerMachine
- **PR√âSERVER l'ordre** actuel des updates (important pour d√©pendances)
- **OUI, d√©pendances critiques** : Controls ‚Üí Systems Update ‚Üí Render Pipeline

#### 3. Int√©gration XState ‚úÖ
- **REMPLACEMENT TOTAL** du syst√®me requestAnimationFrame par XState
- **OUI, g√©rer states** play/pause/stop du render loop avec XState
- **OUI, optimisations** frame skipping et adaptive frame rate n√©cessaires

### üéØ Points de Recherche Sp√©cifiques

#### Performance Critique
- **Frame budget management** (16.67ms pour 60fps)
- **Update scheduling** et priorit√©s des syst√®mes
- **Memory allocation** pendant le render loop
- **Garbage collection** impact sur les frames

#### Patterns XState Avanc√©s
- **Invoke services** pour continuous loops
- **Actor spawning** pour syst√®mes parall√®les
- **State guards** pour performance monitoring
- **Event batching** pour optimisation

#### React Three Fiber Integration
- **useFrame replacement** patterns
- **Fiber scheduling** compatibility
- **Concurrent features** (React 18+) integration
- **Suspension** et error boundaries

### üìä M√©triques de Succ√®s Attendues

Une fois la recherche compl√©t√©e et la FrameSchedulerMachine impl√©ment√©e :
- ‚úÖ **60fps stable** avec 8 syst√®mes
- ‚úÖ **Frame budget respect√©** (<16.67ms)
- ‚úÖ **Zero frame drops** sous charge normale
- ‚úÖ **Debugging am√©lior√©** avec XState DevTools
- ‚úÖ **Architecture scalable** pour autres atomes

### üöÄ LANCEMENT DE LA RECHERCHE

**Maintenant, lance tes recherches avec les mots-cl√©s fournis et ces pr√©cisions techniques !**

Ram√®ne-moi tous les r√©sultats et patterns trouv√©s pour qu'on construise la FrameSchedulerMachine parfaite. üî•

---

## üìä R√âSULTATS DE RECHERCHE COMPIL√âS

### üèóÔ∏è **Architecture du Render Loop Actuel**

L'application utilise actuellement une **boucle de rendu personnalis√©e** bas√©e sur `requestAnimationFrame`, g√©r√©e dans un module React (V3Scene.jsx et useThreeScene.js). Un objet `THREE.Clock` calcule le deltaTime √† chaque frame, et **8 sous-syst√®mes critiques** (contr√¥les cam√©ra, animations, particules, effets, etc.) sont mis √† jour s√©quentiellement √† ~60 FPS avant chaque rendu.

```javascript
// Structure actuelle simplifi√©e
const clock = new THREE.Clock();
function renderLoop() {
  const delta = clock.getDelta();
  controls.update();                // ex: OrbitControls
  animationSystem.update(delta);    // animations mixer
  physicsSystem.update(delta);      // physique / particules
  effectsSystem.update(delta);      // effets visuels (bloom, etc.)
  renderer.render(scene, camera);   // rendu Three.js
  requestAnimationFrame(renderLoop);
}
renderLoop(); // lancement de la boucle
```

Cette approche centralis√©e assure un **ordre d√©terministe** (d'abord inputs/contr√¥les, puis updates logiques, puis rendu) pour √©viter les incoh√©rences. Chaque it√©ration utilise le temps delta √©coul√© pour des mouvements frame-rate independent, assurant une vitesse uniforme sur √©crans 60Hz, 120Hz, etc.

### üîÑ **Int√©gration XState avec Boucle 60FPS**

XState peut piloter une boucle d'animation continue via un **service invoqu√© (callback actor)**. L'id√©e est de d√©marrer la boucle lors de l'entr√©e dans l'√©tat `running` de la machine, puis d'envoyer un √©v√©nement `FRAME_TICK` √† chaque frame :

```javascript
// Pattern XState pour render loop
invoke: {
  src: (context, event) => (sendBack, onReceive) => {
    let prevTime = performance.now();
    function loop(timestamp) {
      const delta = (timestamp - prevTime) / 1000;  // en secondes
      prevTime = timestamp;
      sendBack({ type: 'FRAME_TICK', delta });      // envoie √©v√©nement √† la machine
      requestAnimationFrame(loop);
    }
    const id = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(id); // cleanup quand on quitte l'√©tat
  }
}
```

Ce pattern s'appuie sur l'API `requestAnimationFrame` du navigateur, qui fournit un timestamp haute pr√©cision √† chaque tick et ajuste automatiquement le rythme √† la fr√©quence de rafra√Æchissement de l'√©cran.

### üéÆ **Coordination Multi-Syst√®mes & Ordonnancement**

Avec XState, chaque tick (`FRAME_TICK`) pourra d√©clencher soit une **action unique** qui appelle en s√©quence les 8 syst√®mes, soit √©mettre des √©v√©nements destin√©s √† des machines enfants repr√©sentant chacun un syst√®me.

**Approches possibles :**

1. **Centralis√©e** : Action unique sur `FRAME_TICK` qui appelle successivement tous les syst√®mes
2. **Actorielle** : Chaque sous-syst√®me = machine XState enfant recevant `FRAME_TICK`
3. **Par phases** : Pipeline Capture ‚Üí Update ‚Üí Render avec √©tats XState s√©quentiels

```javascript
// Approche centralis√©e (recommand√©e pour commencer)
on: {
  FRAME_TICK: {
    actions: [
      'updateControls',      // Phase 1: Input
      'updateSystems',       // Phase 2: Logic
      'renderScene'          // Phase 3: Render
    ]
  }
}
```

### ‚ö° **Performance & Bonnes Pratiques 60 FPS**

**Points critiques identifi√©s :**

1. **Utiliser le delta time** : Multiplier d√©placements/animations par delta au lieu d'incr√©ments constants
2. **Limiter les re-renders React** : Ne pas utiliser `setState` dans la loop 60fps
3. **√âviter allocations co√ªteuses** : R√©utiliser objets au lieu de `new` √† chaque frame
4. **Frame skipping/Throttling** : Si surcharge, sauter frames pour maintenir fluidit√©

```javascript
// Pattern performance-friendly
// ‚úÖ BON
position += speed * delta;

// ‚ùå MAUVAIS
position += 0.1; // Fixed value
setState(newPosition); // React re-render
new THREE.Vector3(); // Allocation chaque frame
```

### üéØ **Patterns Cl√©s pour FrameSchedulerMachine**

1. **Service continu XState** avec `requestAnimationFrame`
2. **√âv√©nements `FRAME_TICK`** avec deltaTime
3. **Actions s√©quentielles** pr√©servant l'ordre actuel
4. **Contexte optimis√©** sans re-renders React
5. **Cleanup automatique** via exit du service
6. **Monitoring performance** int√©gr√© au contexte

### üìö **Sources & R√©f√©rences**

- **Three.js Render Loop** : [Three.js Animation Loop Tutorial](https://riptutorial.com/three-js/example/25456/animation-loop)
- **XState Callback Services** : [Stately Docs - Invoking Services](https://stately.ai/docs/xstate/invoking-services#callback-services)
- **RequestAnimationFrame Timing** : [MDN RequestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
- **React Three Fiber Performance** : [R3F Performance Guidelines](https://docs.pmnd.rs/react-three-fiber/advanced/scaling-performance)
- **60fps Maintenance** : [Atlassian Motion Guidelines](https://atlassian.design/foundations/motion/how-to-maintain-60fps)

---

## üîç RECHERCHES COMPL√âMENTAIRES REQUISES

Apr√®s analyse des r√©sultats, **3 recherches suppl√©mentaires critiques** sont n√©cessaires pour un plan technique complet :

### üìã **Recherche 4: Gestion des √âtats d'Erreur et Recovery**

**Mots-cl√©s pour recherche:**
- `XState error handling`
- `requestAnimationFrame error recovery`
- `Three.js error management`
- `render loop crash recovery`
- `XState invoke service error`

**Phrases-cl√©s sp√©cifiques:**
- "XState service onError handling"
- "requestAnimationFrame crash recovery"
- "Three.js renderer context lost"
- "WebGL context restore"

**Objectif:** Comment g√©rer les crashes/erreurs dans le render loop avec XState

### üìã **Recherche 5: Migration Progressive et Coexistence**

**Mots-cl√©s pour recherche:**
- `XState gradual migration`
- `legacy system integration`
- `feature flags XState`
- `A/B testing state machines`
- `progressive enhancement XState`

**Phrases-cl√©s sp√©cifiques:**
- "XState feature flag integration"
- "gradual state machine migration"
- "legacy code XState bridge"
- "progressive XState adoption"

**Objectif:** Comment migrer progressivement sans casser l'existant

### üìã **Recherche 6: DevTools et Debugging en Production**

**Mots-cl√©s pour recherche:**
- `XState devtools production`
- `XState debugging performance impact`
- `state machine monitoring`
- `XState inspector performance`
- `production debugging XState`

**Phrases-cl√©s sp√©cifiques:**
- "XState devtools production overhead"
- "state machine telemetry"
- "XState performance monitoring"
- "debugging 60fps state machines"

**Objectif:** Comment d√©bugger et monitorer la FrameSchedulerMachine en production

## üéØ PRIORIT√âS DES RECHERCHES

- **üî¥ CRITIQUE** : Recherche 4 (Error handling) - Essentiel pour robustesse
- **üü° IMPORTANT** : Recherche 5 (Migration progressive) - Pour √©viter le big bang
- **üü¢ UTILE** : Recherche 6 (DevTools prod) - Pour le monitoring

## üöÄ PROCHAINES √âTAPES

**Lance ces 3 recherches avec les mots-cl√©s fournis, puis ram√®ne-moi tous les r√©sultats !**

Une fois ces recherches compl√©t√©es, je pourrai cr√©er le **plan technique complet et robuste** de la FrameSchedulerMachine avec gestion d'erreurs, migration progressive et monitoring int√©gr√©. üí™

---

## üìã PR√âCISIONS TECHNIQUES POUR LES RECHERCHES COMPL√âMENTAIRES

### üéØ **Contexte Projet et Environnement**

#### 1. Environnement de Production ‚úÖ
- **Type** : Application WebGL Three.js pour extension Chrome (V2_plasmo)
- **Usage** : Outil de visualisation 3D avec effets complexes (bloom, PBR, particules)
- **Criticit√©** : Robustesse importante - crashs WebGL impactent UX utilisateur
- **Public** : Utilisateurs finaux via extension navigateur

#### 2. Strat√©gie de Migration ‚úÖ
- **Scope** : Migration progressive TOUS les atomes (FrameScheduler ‚Üí Bloom ‚Üí PBR ‚Üí etc.)
- **Approche** : Un atome √† la fois, avec coexistence temporaire syst√®mes legacy
- **Timeline** : FrameScheduler = premier atome, puis cascade sur autres syst√®mes
- **Rollback** : Capacit√© de revenir en arri√®re par atome si probl√®me

#### 3. Monitoring et Debug ‚úÖ
- **√âtat actuel** : Pas de monitoring avanc√©, logs console basiques
- **Besoin** : Partir de z√©ro avec solution int√©gr√©e XState
- **Objectif** : Monitoring performance 60fps + state transitions + erreurs WebGL
- **Int√©gration** : DevTools navigateur + XState Inspector + telemetry custom

### üîç **Instructions de Recherche Affin√©es**

Avec ces pr√©cisions, **oriente tes recherches vers** :

#### **Recherche 4** : Focus sur WebGL context recovery + Extension Chrome contraintes
#### **Recherche 5** : Focus sur migration atome par atome + feature flags
#### **Recherche 6** : Focus sur monitoring from scratch + XState Inspector optimal

## üöÄ **LANCEMENT RECHERCHES**

**Maintenant lance les 3 recherches avec ces pr√©cisions contextuelles !** üí™

---

## üìä R√âSULTATS RECHERCHES COMPL√âMENTAIRES

### üî¥ **Gestion des √âtats d'Erreur et Recovery (Recherche 4)**

#### **Transitions onError dans XState**
XState permet de g√©rer les erreurs des services invoqu√©s via des **transitions onError**. Si un service asynchrone lanc√© par la machine rejette ou l√®ve une exception, un √©v√©nement sp√©cial `error.platform.id` est √©mis et peut √™tre intercept√© gr√¢ce √† `onError`. Il est imp√©ratif de d√©finir ces transitions d'erreur pour chaque invocation afin de ne pas ignorer silencieusement les √©checs.

```javascript
// Pattern de gestion d'erreur XState
invoke: {
  src: 'frameLoopService',
  onError: {
    target: 'errorRecovery',
    actions: 'logFrameError'
  }
}
```

#### **Boucle requestAnimationFrame S√©curis√©e**
Une erreur non intercept√©e dans la boucle 60fps peut bloquer le loop ou crasher l'application. La pratique recommand√©e est d'englober le code de rendu dans un **try/catch**, et en cas d'erreur, stopper la boucle d'animation.

```javascript
// Pattern s√©curis√© pour render loop
function secureRenderLoop() {
  try {
    // Code de rendu critique
    updateSystems(deltaTime);
    renderScene();
  } catch (error) {
    // Arr√™t propre + transition XState
    cancelAnimationFrame(animationId);
    sendBack({ type: 'RENDER_ERROR', error });
  }
}
```

#### **Perte du Contexte WebGL et R√©cup√©ration**
En environnement Three.js/WebGL, les crashes peuvent provenir d'une **perte du contexte WebGL** (GPU satur√©, onglet en arri√®re-plan). Pour g√©rer cela :

1. **√âcouter** `'webglcontextlost'` sur le canvas + `event.preventDefault()`
2. **Stopper** le rendu (annuler requestAnimationFrame)
3. **Attendre** `'webglcontextrestored'` pour recr√©er les ressources WebGL
4. **R√©initialiser** l'√©tat du renderer et reprendre

```javascript
// √âtats XState pour contexte WebGL
states: {
  running: { /* render loop normal */ },
  contextLost: {
    entry: 'stopRenderLoop',
    on: {
      CONTEXT_RESTORED: {
        target: 'recovering',
        actions: 'reinitializeWebGL'
      }
    }
  },
  recovering: {
    invoke: {
      src: 'restoreWebGLResources',
      onDone: 'running'
    }
  }
}
```

### üü° **Migration Progressive et Coexistence (Recherche 5)**

#### **Remplacement Incr√©mental par "Atome"**
Plut√¥t que de basculer tout le syst√®me d'un coup, adopter une approche incr√©mentale **feature by feature**. Cela s'apparente au patron **Strangler Fig** en modernisation logicielle : d√©placer progressivement des portions de comportement du syst√®me legacy vers le nouveau syst√®me.

```javascript
// Pattern de coexistence
const useRenderLoop = () => {
  if (FEATURE_FLAGS.USE_XSTATE_FRAME_SCHEDULER) {
    return useXStateFrameScheduler();
  }
  return useLegacyRenderLoop(); // Fallback
};
```

#### **Coexistence via Feature Flags**
Durant la transition, l'ancien et le nouveau syst√®me cohabitent. L'activation se fait via des **feature flags** pour contr√¥ler finement qui utilise la nouvelle impl√©mentation :

- **D√©veloppeurs** : 100% nouvelle implementation
- **Canary release** : 5% utilisateurs s√©lectionn√©s
- **Rollout progressif** : 25% ‚Üí 50% ‚Üí 100%

```javascript
// Configuration feature flags
const MIGRATION_FLAGS = {
  FRAME_SCHEDULER_XSTATE: {
    dev: true,
    staging: true,
    production: getUserSegment() < 0.25 // 25% users
  }
};
```

#### **Strat√©gie de Rollback Simple**
Les feature flags offrent un **m√©canisme de repli imm√©diat**. Si la nouvelle machine provoque une r√©gression, il suffit de d√©sactiver le flag pour que tous les utilisateurs repassent instantan√©ment sur l'ancien module stable.

### üü¢ **DevTools et Debugging en Production (Recherche 6)**

#### **Utilisation Mesur√©e de XState Inspector**
XState Inspector est puissant pour le d√©veloppement mais **pas viable en production** sur un loop 60fps (volume d'√©v√©nements √©norme). La strat√©gie recommand√©e :

```javascript
// Debug conditionnel
if (process.env.NODE_ENV === 'development' || window.__XSTATE_DEBUG__) {
  import('@xstate/inspect').then(({ inspect }) => {
    inspect({ iframe: false });
  });
}
```

#### **Logging et Tra√ßage Personnalis√©s**
En production, instrumenter la machine pour remonter **les informations cl√©s uniquement** :

```javascript
// Logging s√©lectif dans la machine
const frameSchedulerMachine = createMachine({
  // ...
  states: {
    errorRecovery: {
      entry: (context, event) => {
        console.error('FrameScheduler error:', event.data);
        // T√©l√©m√©trie vers service monitoring
        sendTelemetry('frame_scheduler_error', {
          error: event.data,
          timestamp: Date.now(),
          context: context
        });
      }
    }
  }
});
```

#### **Surveillance Performance 60fps**
Monitorer le temps d'ex√©cution du render loop avec alertes si d√©passement du budget frame (16.67ms) :

```javascript
// Performance monitoring int√©gr√©
const performanceContext = {
  frameCount: 0,
  averageFrameTime: 16.67,
  slowFrameCount: 0,
  lastFrameTime: 0
};

// Dans l'action FRAME_TICK
actions: {
  updatePerformanceMetrics: assign((context, event) => {
    const frameTime = event.deltaTime * 1000; // ms
    const slowFrame = frameTime > 20; // Seuil d'alerte

    if (slowFrame) {
      console.warn('Slow frame detected:', frameTime + 'ms');
      context.slowFrameCount++;
    }

    return {
      ...context,
      frameCount: context.frameCount + 1,
      averageFrameTime: (context.averageFrameTime + frameTime) / 2,
      lastFrameTime: frameTime
    };
  })
}
```

### üìö **Sources Recherches Compl√©mentaires**

#### **üî¥ Error Handling**
- [XState Error Handling](https://xstate.js.org/docs/guides/communication.html#invoking-promises)
- [WebGL Context Lost Handling](https://www.khronos.org/webgl/wiki/HandlingContextLost)
- [RequestAnimationFrame Error Recovery](https://stackoverflow.com/questions/67789610/what-to-do-when-the-requestanimationframe-loop-crashes-in-javascript)

#### **üü° Progressive Migration**
- [Strangler Fig Pattern](https://martinfowler.com/bliki/StranglerFigApplication.html)
- [Feature Flags Canary Release](https://launchdarkly.com/blog/feature-flags-canary-releases)
- [Rollback Strategies](https://launchdarkly.com/blog/feature-flag-rollback)

#### **üü¢ DevTools & Monitoring**
- [XState Inspector](https://stately.ai/docs/inspect)
- [XState Error States](https://xstate.js.org/docs/guides/states.html#error-states)
- [Performance Monitoring Patterns](https://web.dev/user-centric-performance-metrics/)