# ğŸ¯ PREMIER ATOME: RENDER LOOP â†’ FRAMESCHEDULER

## ğŸš€ CHOIX STRATÃ‰GIQUE

**Atome D1 (Render Loop â†’ FrameSchedulerMachine)** choisi comme point de dÃ©part car :
- ğŸ—ï¸ **Fondation architecturale** - Impact sur tous les autres systÃ¨mes
- âš¡ **Performance critique** - 60fps, 8 systÃ¨mes Ã  coordonner
- ğŸ”„ **Pattern rÃ©utilisable** - Servira pour tous les autres atomes

## ğŸ” RECHERCHES REQUISES

### ğŸ“‹ Recherche 1: Architecture Render Loop Actuelle
**Mots-clÃ©s pour recherche:**
- `useFrame`
- `requestAnimationFrame`
- `deltaTime`
- `update`
- `render loop`
- `animation controller`

**Phrases-clÃ©s spÃ©cifiques:**
- "startRenderLoop"
- "animationControllerRef.current?.update"
- "useFrame hook"
- "deltaTime calculation"

**Objectif:** Comprendre l'implÃ©mentation actuelle complÃ¨te

### ğŸ“‹ Recherche 2: IntÃ©gration XState avec Render Loop
**Mots-clÃ©s pour recherche:**
- `XState invoke`
- `XState services`
- `React useFrame`
- `frame scheduling`
- `XState React integration`

**Phrases-clÃ©s spÃ©cifiques:**
- "XState with requestAnimationFrame"
- "XState invoke service continuous"
- "React Three Fiber useFrame XState"
- "XState frame loop pattern"

**Objectif:** Patterns d'intÃ©gration XState + render loop

### ğŸ“‹ Recherche 3: Performance et Optimisation
**Mots-clÃ©s pour recherche:**
- `React Three Fiber performance`
- `useFrame optimization`
- `XState performance`
- `frame scheduling`

**Phrases-clÃ©s spÃ©cifiques:**
- "useFrame performance best practices"
- "XState service performance"
- "frame scheduling optimization"
- "React Three Fiber 60fps"

**Objectif:** Optimisations et bonnes pratiques

## ğŸ”„ PROCESS COLLABORATIF

### Ã‰tapes
1. **Toi:** Lancer les 3 recherches avec ces mots-clÃ©s
2. **Toi:** Me donner TOUS les rÃ©sultats trouvÃ©s
3. **Moi:** Analyser et compiler toutes les infos
4. **Moi:** DÃ©finir le plan technique prÃ©cis FrameSchedulerMachine
5. **Ensemble:** Valider la faisabilitÃ© du plan
6. **Moi:** Coder la FrameSchedulerMachine
7. **Ensemble:** Tester et valider l'implÃ©mentation
8. **Moi:** Documenter pour les autres atomes

### RÃ©sultats Attendus
AprÃ¨s tes recherches, je pourrai crÃ©er :
- âœ… **FrameSchedulerMachine** complÃ¨te et optimisÃ©e
- âœ… **Patterns rÃ©utilisables** pour les autres atomes
- âœ… **Architecture solide** pour tout le systÃ¨me XState

## ğŸ¯ LIVRABLE FINAL ATOME D1

```javascript
// Preview de ce qu'on va crÃ©er
const frameSchedulerMachine = createMachine({
  id: 'frameScheduler',

  states: {
    idle: { /* ... */ },
    running: {
      invoke: {
        src: 'frameLoop', // Service basÃ© sur tes recherches
        // Coordination des 8 systÃ¨mes
      }
    }
  }
});
```

## ğŸš€ READY ?

**Lance les recherches et ramÃ¨ne-moi tout !**

Ensuite on crÃ©e ensemble la meilleure FrameSchedulerMachine possible. ğŸ’ª

---

## ğŸ” PRÃ‰CISIONS TECHNIQUES POUR LA RECHERCHE

### ğŸ“‹ RÃ©ponses aux Questions Techniques

#### 1. SystÃ¨me de Render Loop Actuel âœ…
- **NON, PAS React Three Fiber** - SystÃ¨me custom basÃ© sur requestAnimationFrame
- **8 systÃ¨mes coordonnÃ©s** via un callback unique dans startRenderLoop (V3Scene.jsx)
- **Structure exacte** : useThreeScene.js lignes 207-241 avec THREE.Clock pour deltaTime

#### 2. Architecture Multi-SystÃ¨mes âœ…
- **OUI, gestion synchronisÃ©e** de tous les systÃ¨mes dans la FrameSchedulerMachine
- **PRÃ‰SERVER l'ordre** actuel des updates (important pour dÃ©pendances)
- **OUI, dÃ©pendances critiques** : Controls â†’ Systems Update â†’ Render Pipeline

#### 3. IntÃ©gration XState âœ…
- **REMPLACEMENT TOTAL** du systÃ¨me requestAnimationFrame par XState
- **OUI, gÃ©rer states** play/pause/stop du render loop avec XState
- **OUI, optimisations** frame skipping et adaptive frame rate nÃ©cessaires

### ğŸ¯ Points de Recherche SpÃ©cifiques

#### Performance Critique
- **Frame budget management** (16.67ms pour 60fps)
- **Update scheduling** et prioritÃ©s des systÃ¨mes
- **Memory allocation** pendant le render loop
- **Garbage collection** impact sur les frames

#### Patterns XState AvancÃ©s
- **Invoke services** pour continuous loops
- **Actor spawning** pour systÃ¨mes parallÃ¨les
- **State guards** pour performance monitoring
- **Event batching** pour optimisation

#### React Three Fiber Integration
- **useFrame replacement** patterns
- **Fiber scheduling** compatibility
- **Concurrent features** (React 18+) integration
- **Suspension** et error boundaries

### ğŸ“Š MÃ©triques de SuccÃ¨s Attendues

Une fois la recherche complÃ©tÃ©e et la FrameSchedulerMachine implÃ©mentÃ©e :
- âœ… **60fps stable** avec 8 systÃ¨mes
- âœ… **Frame budget respectÃ©** (<16.67ms)
- âœ… **Zero frame drops** sous charge normale
- âœ… **Debugging amÃ©liorÃ©** avec XState DevTools
- âœ… **Architecture scalable** pour autres atomes

### ğŸš€ LANCEMENT DE LA RECHERCHE

**Maintenant, lance tes recherches avec les mots-clÃ©s fournis et ces prÃ©cisions techniques !**

RamÃ¨ne-moi tous les rÃ©sultats et patterns trouvÃ©s pour qu'on construise la FrameSchedulerMachine parfaite. ğŸ”¥

---

## ğŸ“Š RÃ‰SULTATS DE RECHERCHE COMPILÃ‰S

### ğŸ—ï¸ **Architecture du Render Loop Actuel**

L'application utilise actuellement une **boucle de rendu personnalisÃ©e** basÃ©e sur `requestAnimationFrame`, gÃ©rÃ©e dans un module React (V3Scene.jsx et useThreeScene.js). Un objet `THREE.Clock` calcule le deltaTime Ã  chaque frame, et **8 sous-systÃ¨mes critiques** (contrÃ´les camÃ©ra, animations, particules, effets, etc.) sont mis Ã  jour sÃ©quentiellement Ã  ~60 FPS avant chaque rendu.

```javascript
// Structure actuelle simplifiÃ©e
const clock = new THREE.Clock();
function renderLoop() {
  const delta = clock.getDelta();
  controls.update();                // ex: OrbitControls
  animationSystem.update(delta);    // animations mixer
  physicsSystem.update(delta);      // physique / particules
  effectsSystem.update(delta);      // effets visuels (bloom, etc.)
  renderer.render(scene, camera);   // rendu Three.js
  requestAnimationFrame(renderLoop);
}
renderLoop(); // lancement de la boucle
```

Cette approche centralisÃ©e assure un **ordre dÃ©terministe** (d'abord inputs/contrÃ´les, puis updates logiques, puis rendu) pour Ã©viter les incohÃ©rences. Chaque itÃ©ration utilise le temps delta Ã©coulÃ© pour des mouvements frame-rate independent, assurant une vitesse uniforme sur Ã©crans 60Hz, 120Hz, etc.

### ğŸ”„ **IntÃ©gration XState avec Boucle 60FPS**

XState peut piloter une boucle d'animation continue via un **service invoquÃ© (callback actor)**. L'idÃ©e est de dÃ©marrer la boucle lors de l'entrÃ©e dans l'Ã©tat `running` de la machine, puis d'envoyer un Ã©vÃ©nement `FRAME_TICK` Ã  chaque frame :

```javascript
// Pattern XState pour render loop
invoke: {
  src: (context, event) => (sendBack, onReceive) => {
    let prevTime = performance.now();
    function loop(timestamp) {
      const delta = (timestamp - prevTime) / 1000;  // en secondes
      prevTime = timestamp;
      sendBack({ type: 'FRAME_TICK', delta });      // envoie Ã©vÃ©nement Ã  la machine
      requestAnimationFrame(loop);
    }
    const id = requestAnimationFrame(loop);
    return () => cancelAnimationFrame(id); // cleanup quand on quitte l'Ã©tat
  }
}
```

Ce pattern s'appuie sur l'API `requestAnimationFrame` du navigateur, qui fournit un timestamp haute prÃ©cision Ã  chaque tick et ajuste automatiquement le rythme Ã  la frÃ©quence de rafraÃ®chissement de l'Ã©cran.

### ğŸ® **Coordination Multi-SystÃ¨mes & Ordonnancement**

Avec XState, chaque tick (`FRAME_TICK`) pourra dÃ©clencher soit une **action unique** qui appelle en sÃ©quence les 8 systÃ¨mes, soit Ã©mettre des Ã©vÃ©nements destinÃ©s Ã  des machines enfants reprÃ©sentant chacun un systÃ¨me.

**Approches possibles :**

1. **CentralisÃ©e** : Action unique sur `FRAME_TICK` qui appelle successivement tous les systÃ¨mes
2. **Actorielle** : Chaque sous-systÃ¨me = machine XState enfant recevant `FRAME_TICK`
3. **Par phases** : Pipeline Capture â†’ Update â†’ Render avec Ã©tats XState sÃ©quentiels

```javascript
// Approche centralisÃ©e (recommandÃ©e pour commencer)
on: {
  FRAME_TICK: {
    actions: [
      'updateControls',      // Phase 1: Input
      'updateSystems',       // Phase 2: Logic
      'renderScene'          // Phase 3: Render
    ]
  }
}
```

### âš¡ **Performance & Bonnes Pratiques 60 FPS**

**Points critiques identifiÃ©s :**

1. **Utiliser le delta time** : Multiplier dÃ©placements/animations par delta au lieu d'incrÃ©ments constants
2. **Limiter les re-renders React** : Ne pas utiliser `setState` dans la loop 60fps
3. **Ã‰viter allocations coÃ»teuses** : RÃ©utiliser objets au lieu de `new` Ã  chaque frame
4. **Frame skipping/Throttling** : Si surcharge, sauter frames pour maintenir fluiditÃ©

```javascript
// Pattern performance-friendly
// âœ… BON
position += speed * delta;

// âŒ MAUVAIS
position += 0.1; // Fixed value
setState(newPosition); // React re-render
new THREE.Vector3(); // Allocation chaque frame
```

### ğŸ¯ **Patterns ClÃ©s pour FrameSchedulerMachine**

1. **Service continu XState** avec `requestAnimationFrame`
2. **Ã‰vÃ©nements `FRAME_TICK`** avec deltaTime
3. **Actions sÃ©quentielles** prÃ©servant l'ordre actuel
4. **Contexte optimisÃ©** sans re-renders React
5. **Cleanup automatique** via exit du service
6. **Monitoring performance** intÃ©grÃ© au contexte

### ğŸ“š **Sources & RÃ©fÃ©rences**

- **Three.js Render Loop** : [Three.js Animation Loop Tutorial](https://riptutorial.com/three-js/example/25456/animation-loop)
- **XState Callback Services** : [Stately Docs - Invoking Services](https://stately.ai/docs/xstate/invoking-services#callback-services)
- **RequestAnimationFrame Timing** : [MDN RequestAnimationFrame](https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame)
- **React Three Fiber Performance** : [R3F Performance Guidelines](https://docs.pmnd.rs/react-three-fiber/advanced/scaling-performance)
- **60fps Maintenance** : [Atlassian Motion Guidelines](https://atlassian.design/foundations/motion/how-to-maintain-60fps)

---

## ğŸ” RECHERCHES COMPLÃ‰MENTAIRES REQUISES

AprÃ¨s analyse des rÃ©sultats, **3 recherches supplÃ©mentaires critiques** sont nÃ©cessaires pour un plan technique complet :

### ğŸ“‹ **Recherche 4: Gestion des Ã‰tats d'Erreur et Recovery**

**Mots-clÃ©s pour recherche:**
- `XState error handling`
- `requestAnimationFrame error recovery`
- `Three.js error management`
- `render loop crash recovery`
- `XState invoke service error`

**Phrases-clÃ©s spÃ©cifiques:**
- "XState service onError handling"
- "requestAnimationFrame crash recovery"
- "Three.js renderer context lost"
- "WebGL context restore"

**Objectif:** Comment gÃ©rer les crashes/erreurs dans le render loop avec XState

### ğŸ“‹ **Recherche 5: Migration Progressive et Coexistence**

**Mots-clÃ©s pour recherche:**
- `XState gradual migration`
- `legacy system integration`
- `feature flags XState`
- `A/B testing state machines`
- `progressive enhancement XState`

**Phrases-clÃ©s spÃ©cifiques:**
- "XState feature flag integration"
- "gradual state machine migration"
- "legacy code XState bridge"
- "progressive XState adoption"

**Objectif:** Comment migrer progressivement sans casser l'existant

### ğŸ“‹ **Recherche 6: DevTools et Debugging en Production**

**Mots-clÃ©s pour recherche:**
- `XState devtools production`
- `XState debugging performance impact`
- `state machine monitoring`
- `XState inspector performance`
- `production debugging XState`

**Phrases-clÃ©s spÃ©cifiques:**
- "XState devtools production overhead"
- "state machine telemetry"
- "XState performance monitoring"
- "debugging 60fps state machines"

**Objectif:** Comment dÃ©bugger et monitorer la FrameSchedulerMachine en production

## ğŸ¯ PRIORITÃ‰S DES RECHERCHES

- **ğŸ”´ CRITIQUE** : Recherche 4 (Error handling) - Essentiel pour robustesse
- **ğŸŸ¡ IMPORTANT** : Recherche 5 (Migration progressive) - Pour Ã©viter le big bang
- **ğŸŸ¢ UTILE** : Recherche 6 (DevTools prod) - Pour le monitoring

## ğŸš€ PROCHAINES Ã‰TAPES

**Lance ces 3 recherches avec les mots-clÃ©s fournis, puis ramÃ¨ne-moi tous les rÃ©sultats !**

Une fois ces recherches complÃ©tÃ©es, je pourrai crÃ©er le **plan technique complet et robuste** de la FrameSchedulerMachine avec gestion d'erreurs, migration progressive et monitoring intÃ©grÃ©. ğŸ’ª

---

## ğŸ“‹ PRÃ‰CISIONS TECHNIQUES POUR LES RECHERCHES COMPLÃ‰MENTAIRES

### ğŸ¯ **Contexte Projet et Environnement**

#### 1. Environnement de Production âœ…
- **Type** : Application WebGL Three.js pour extension Chrome (V2_plasmo)
- **Usage** : Outil de visualisation 3D avec effets complexes (bloom, PBR, particules)
- **CriticitÃ©** : Robustesse importante - crashs WebGL impactent UX utilisateur
- **Public** : Utilisateurs finaux via extension navigateur

#### 2. StratÃ©gie de Migration âœ…
- **Scope** : Migration progressive TOUS les atomes (FrameScheduler â†’ Bloom â†’ PBR â†’ etc.)
- **Approche** : Un atome Ã  la fois, avec coexistence temporaire systÃ¨mes legacy
- **Timeline** : FrameScheduler = premier atome, puis cascade sur autres systÃ¨mes
- **Rollback** : CapacitÃ© de revenir en arriÃ¨re par atome si problÃ¨me

#### 3. Monitoring et Debug âœ…
- **Ã‰tat actuel** : Pas de monitoring avancÃ©, logs console basiques
- **Besoin** : Partir de zÃ©ro avec solution intÃ©grÃ©e XState
- **Objectif** : Monitoring performance 60fps + state transitions + erreurs WebGL
- **IntÃ©gration** : DevTools navigateur + XState Inspector + telemetry custom

### ğŸ” **Instructions de Recherche AffinÃ©es**

Avec ces prÃ©cisions, **oriente tes recherches vers** :

#### **Recherche 4** : Focus sur WebGL context recovery + Extension Chrome contraintes
#### **Recherche 5** : Focus sur migration atome par atome + feature flags
#### **Recherche 6** : Focus sur monitoring from scratch + XState Inspector optimal

## ğŸš€ **LANCEMENT RECHERCHES**

**Maintenant lance les 3 recherches avec ces prÃ©cisions contextuelles !** ğŸ’ª

---

## ğŸ“Š RÃ‰SULTATS RECHERCHES COMPLÃ‰MENTAIRES

### ğŸ”´ **Gestion des Ã‰tats d'Erreur et Recovery (Recherche 4)**

#### **Transitions onError dans XState**
XState permet de gÃ©rer les erreurs des services invoquÃ©s via des **transitions onError**. Si un service asynchrone lancÃ© par la machine rejette ou lÃ¨ve une exception, un Ã©vÃ©nement spÃ©cial `error.platform.id` est Ã©mis et peut Ãªtre interceptÃ© grÃ¢ce Ã  `onError`. Il est impÃ©ratif de dÃ©finir ces transitions d'erreur pour chaque invocation afin de ne pas ignorer silencieusement les Ã©checs.

```javascript
// Pattern de gestion d'erreur XState
invoke: {
  src: 'frameLoopService',
  onError: {
    target: 'errorRecovery',
    actions: 'logFrameError'
  }
}
```

#### **Boucle requestAnimationFrame SÃ©curisÃ©e**
Une erreur non interceptÃ©e dans la boucle 60fps peut bloquer le loop ou crasher l'application. La pratique recommandÃ©e est d'englober le code de rendu dans un **try/catch**, et en cas d'erreur, stopper la boucle d'animation.

```javascript
// Pattern sÃ©curisÃ© pour render loop
function secureRenderLoop() {
  try {
    // Code de rendu critique
    updateSystems(deltaTime);
    renderScene();
  } catch (error) {
    // ArrÃªt propre + transition XState
    cancelAnimationFrame(animationId);
    sendBack({ type: 'RENDER_ERROR', error });
  }
}
```

#### **Perte du Contexte WebGL et RÃ©cupÃ©ration**
En environnement Three.js/WebGL, les crashes peuvent provenir d'une **perte du contexte WebGL** (GPU saturÃ©, onglet en arriÃ¨re-plan). Pour gÃ©rer cela :

1. **Ã‰couter** `'webglcontextlost'` sur le canvas + `event.preventDefault()`
2. **Stopper** le rendu (annuler requestAnimationFrame)
3. **Attendre** `'webglcontextrestored'` pour recrÃ©er les ressources WebGL
4. **RÃ©initialiser** l'Ã©tat du renderer et reprendre

```javascript
// Ã‰tats XState pour contexte WebGL
states: {
  running: { /* render loop normal */ },
  contextLost: {
    entry: 'stopRenderLoop',
    on: {
      CONTEXT_RESTORED: {
        target: 'recovering',
        actions: 'reinitializeWebGL'
      }
    }
  },
  recovering: {
    invoke: {
      src: 'restoreWebGLResources',
      onDone: 'running'
    }
  }
}
```

### ğŸŸ¡ **Migration Progressive et Coexistence (Recherche 5)**

#### **Remplacement IncrÃ©mental par "Atome"**
PlutÃ´t que de basculer tout le systÃ¨me d'un coup, adopter une approche incrÃ©mentale **feature by feature**. Cela s'apparente au patron **Strangler Fig** en modernisation logicielle : dÃ©placer progressivement des portions de comportement du systÃ¨me legacy vers le nouveau systÃ¨me.

```javascript
// Pattern de coexistence
const useRenderLoop = () => {
  if (FEATURE_FLAGS.USE_XSTATE_FRAME_SCHEDULER) {
    return useXStateFrameScheduler();
  }
  return useLegacyRenderLoop(); // Fallback
};
```

#### **Coexistence via Feature Flags**
Durant la transition, l'ancien et le nouveau systÃ¨me cohabitent. L'activation se fait via des **feature flags** pour contrÃ´ler finement qui utilise la nouvelle implÃ©mentation :

- **DÃ©veloppeurs** : 100% nouvelle implementation
- **Canary release** : 5% utilisateurs sÃ©lectionnÃ©s
- **Rollout progressif** : 25% â†’ 50% â†’ 100%

```javascript
// Configuration feature flags
const MIGRATION_FLAGS = {
  FRAME_SCHEDULER_XSTATE: {
    dev: true,
    staging: true,
    production: getUserSegment() < 0.25 // 25% users
  }
};
```

#### **StratÃ©gie de Rollback Simple**
Les feature flags offrent un **mÃ©canisme de repli immÃ©diat**. Si la nouvelle machine provoque une rÃ©gression, il suffit de dÃ©sactiver le flag pour que tous les utilisateurs repassent instantanÃ©ment sur l'ancien module stable.

### ğŸŸ¢ **DevTools et Debugging en Production (Recherche 6)**

#### **Utilisation MesurÃ©e de XState Inspector**
XState Inspector est puissant pour le dÃ©veloppement mais **pas viable en production** sur un loop 60fps (volume d'Ã©vÃ©nements Ã©norme). La stratÃ©gie recommandÃ©e :

```javascript
// Debug conditionnel
if (process.env.NODE_ENV === 'development' || window.__XSTATE_DEBUG__) {
  import('@xstate/inspect').then(({ inspect }) => {
    inspect({ iframe: false });
  });
}
```

#### **Logging et TraÃ§age PersonnalisÃ©s**
En production, instrumenter la machine pour remonter **les informations clÃ©s uniquement** :

```javascript
// Logging sÃ©lectif dans la machine
const frameSchedulerMachine = createMachine({
  // ...
  states: {
    errorRecovery: {
      entry: (context, event) => {
        console.error('FrameScheduler error:', event.data);
        // TÃ©lÃ©mÃ©trie vers service monitoring
        sendTelemetry('frame_scheduler_error', {
          error: event.data,
          timestamp: Date.now(),
          context: context
        });
      }
    }
  }
});
```

#### **Surveillance Performance 60fps**
Monitorer le temps d'exÃ©cution du render loop avec alertes si dÃ©passement du budget frame (16.67ms) :

```javascript
// Performance monitoring intÃ©grÃ©
const performanceContext = {
  frameCount: 0,
  averageFrameTime: 16.67,
  slowFrameCount: 0,
  lastFrameTime: 0
};

// Dans l'action FRAME_TICK
actions: {
  updatePerformanceMetrics: assign((context, event) => {
    const frameTime = event.deltaTime * 1000; // ms
    const slowFrame = frameTime > 20; // Seuil d'alerte

    if (slowFrame) {
      console.warn('Slow frame detected:', frameTime + 'ms');
      context.slowFrameCount++;
    }

    return {
      ...context,
      frameCount: context.frameCount + 1,
      averageFrameTime: (context.averageFrameTime + frameTime) / 2,
      lastFrameTime: frameTime
    };
  })
}
```

### ğŸ“š **Sources Recherches ComplÃ©mentaires**

#### **ğŸ”´ Error Handling**
- [XState Error Handling](https://xstate.js.org/docs/guides/communication.html#invoking-promises)
- [WebGL Context Lost Handling](https://www.khronos.org/webgl/wiki/HandlingContextLost)
- [RequestAnimationFrame Error Recovery](https://stackoverflow.com/questions/67789610/what-to-do-when-the-requestanimationframe-loop-crashes-in-javascript)

#### **ğŸŸ¡ Progressive Migration**
- [Strangler Fig Pattern](https://martinfowler.com/bliki/StranglerFigApplication.html)
- [Feature Flags Canary Release](https://launchdarkly.com/blog/feature-flags-canary-releases)
- [Rollback Strategies](https://launchdarkly.com/blog/feature-flag-rollback)

#### **ğŸŸ¢ DevTools & Monitoring**
- [XState Inspector](https://stately.ai/docs/inspect)
- [XState Error States](https://xstate.js.org/docs/guides/states.html#error-states)
- [Performance Monitoring Patterns](https://web.dev/user-centric-performance-metrics/)